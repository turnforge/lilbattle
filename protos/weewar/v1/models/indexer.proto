syntax = "proto3";

package weewar.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
import "google/protobuf/field_mask.proto";

message EntityIndexState {
    string entity_type = 1;
    string entity_id = 2;

    // eg "screenshots", "keywords" etc
    // EntityType + EntityId + IndexType should be  unique
    string index_type = 3;


    // When the last indexing was queued
    google.protobuf.Timestamp last_queued_at = 4;

    // when the last indexing was completed
    google.protobuf.Timestamp last_indexed_at = 5;

    // "queued/pending", "indexing", "completed", "failed"
    string status = 6;

    // If there was an error in the last indexing
    string last_error = 7;

    // Keep a hash of the contents for quick check to check updated
    // (not sure if needed) - This should be provided by the source
    string last_content_hash = 8;

    int32 retry_count = 9;

    // Which LRO this entity has been updated via
    string current_lro_id = 10;
}


// Index States specific APIs

message GetIndexStatesRequest {
  string entity_type = 1;
  repeated string entity_ids = 2;

  // Optional - can be used to get "all" indexer states or just once specified here
  repeated string index_types = 3;   
}

message EntityIndexStateList {
  repeated EntityIndexState states = 1;
}

message GetIndexStatesResponse {
  map<string, EntityIndexStateList> states = 1;
}

message ListIndexStatesRequest {
  string entity_type = 1;

  // Get records indexed "before" this time
  optional google.protobuf.Timestamp indexed_before = 2;

  // Get records indexed "after" this time
  optional google.protobuf.Timestamp indexed_after = 3;

  // Filter by index types or get all
  repeated string index_types = 4;   

  // "id" or "indexed_at"
  string order_by = 5;

  // limit to max items
  int32 count = 6;
}

message ListIndexStatesResponse {
  repeated EntityIndexState items = 1;

  // How to identify the next "page" in this list
  string next_page_key = 2;
}

message DeleteIndexStatesRequest {
  string entity_type = 1;
  repeated string entity_ids = 2;

  // Optional - can be used to get "all" indexer states or just once specified here
  repeated string index_types = 3;   
}

message DeleteIndexStatesResponse {
}

// Messages for CRUD on the index LRO itself

// Request messages
message IndexRecord {
  string entity_id = 2;
  google.protobuf.Timestamp updated_at = 3;
  google.protobuf.Any entity_data = 4;
  repeated string indexer_types = 5;
}

// Each IndexRecords gets its own "long running operation" 
// so we can track how things are
message IndexRecordsLRO {
  string lro_id = 1;  // Customizable by source if it can guarantee uniqueness

  // Single entity type in a index request
  string entity_type = 2;

  // When this request was created
  google.protobuf.Timestamp created_at = 3;
  google.protobuf.Timestamp updated_at = 4;

  // Callback url for this request (if any)
  // All records indexed in this operation will be notified via this url
  string callback_url = 5;

  // Records to enqueue - note that indexing by its nature is asynchronous
  // so we wont wait for all the indexing to finish
  repeated IndexRecord records = 6;
}

message CreateIndexRecordsLRORequest {
  IndexRecordsLRO lro = 1;
}

message CreateIndexRecordsLROResponse {
  IndexRecordsLRO lro = 1;
}

message UpdateIndexRecordsLRORequest {
  IndexRecordsLRO lro = 1;

  /**
   * Mask of fields being updated in this Game to make partial changes.
   */
  google.protobuf.FieldMask update_mask = 2;
}

message UpdateIndexRecordsLROResponse {
  IndexRecordsLRO lro = 1;
}


message GetIndexRecordsLRORequest {
  string lro_id = 1;
}

message GetIndexRecordsLROResponse {
  IndexRecordsLRO lro = 1;
}

