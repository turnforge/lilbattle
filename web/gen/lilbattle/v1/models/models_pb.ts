// @generated by protoc-gen-es v2.9.0 with parameter "target=ts"
// @generated from file lilbattle/v1/models/models.proto (package lilbattle.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file lilbattle/v1/models/models.proto.
 */
export const file_lilbattle_v1_models_models: GenFile = /*@__PURE__*/
  fileDesc("CiBsaWxiYXR0bGUvdjEvbW9kZWxzL21vZGVscy5wcm90bxIMbGlsYmF0dGxlLnYxIo0BCglJbmRleEluZm8SMwoPbGFzdF91cGRhdGVkX2F0GAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIzCg9sYXN0X2luZGV4ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhYKDm5lZWRzX2luZGV4aW5nGAMgASgIIkYKClBhZ2luYXRpb24SEAoIcGFnZV9rZXkYASABKAkSEwoLcGFnZV9vZmZzZXQYAiABKAUSEQoJcGFnZV9zaXplGAMgASgFIm4KElBhZ2luYXRpb25SZXNwb25zZRIVCg1uZXh0X3BhZ2Vfa2V5GAIgASgJEhgKEG5leHRfcGFnZV9vZmZzZXQYAyABKAUSEAoIaGFzX21vcmUYBCABKAgSFQoNdG90YWxfcmVzdWx0cxgFIAEoBSL4AgoFV29ybGQSLgoKY3JlYXRlZF9hdBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKdXBkYXRlZF9hdBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDwoHdmVyc2lvbhgDIAEoAxIKCgJpZBgEIAEoCRISCgpjcmVhdG9yX2lkGAUgASgJEgwKBG5hbWUYBiABKAkSEwoLZGVzY3JpcHRpb24YByABKAkSDAoEdGFncxgIIAMoCRIRCglpbWFnZV91cmwYCSABKAkSEgoKZGlmZmljdWx0eRgKIAEoCRIUCgxwcmV2aWV3X3VybHMYCyADKAkSPAoTZGVmYXVsdF9nYW1lX2NvbmZpZxgMIAEoCzIfLmxpbGJhdHRsZS52MS5HYW1lQ29uZmlndXJhdGlvbhIyChFzZWFyY2hfaW5kZXhfaW5mbxgNIAEoCzIXLmxpbGJhdHRsZS52MS5JbmRleEluZm8i7QMKCVdvcmxkRGF0YRI4Cgl0aWxlc19tYXAYASADKAsyJS5saWxiYXR0bGUudjEuV29ybGREYXRhLlRpbGVzTWFwRW50cnkSOAoJdW5pdHNfbWFwGAIgAygLMiUubGlsYmF0dGxlLnYxLldvcmxkRGF0YS5Vbml0c01hcEVudHJ5EjYKFXNjcmVlbnNob3RfaW5kZXhfaW5mbxgDIAEoCzIXLmxpbGJhdHRsZS52MS5JbmRleEluZm8SFAoMY29udGVudF9oYXNoGAQgASgJEg8KB3ZlcnNpb24YBSABKAMSOQoJY3Jvc3NpbmdzGAggAygLMiYubGlsYmF0dGxlLnYxLldvcmxkRGF0YS5Dcm9zc2luZ3NFbnRyeRpDCg1UaWxlc01hcEVudHJ5EgsKA2tleRgBIAEoCRIhCgV2YWx1ZRgCIAEoCzISLmxpbGJhdHRsZS52MS5UaWxlOgI4ARpDCg1Vbml0c01hcEVudHJ5EgsKA2tleRgBIAEoCRIhCgV2YWx1ZRgCIAEoCzISLmxpbGJhdHRsZS52MS5Vbml0OgI4ARpICg5Dcm9zc2luZ3NFbnRyeRILCgNrZXkYASABKAkSJQoFdmFsdWUYAiABKAsyFi5saWxiYXR0bGUudjEuQ3Jvc3Npbmc6AjgBIkkKCENyb3NzaW5nEigKBHR5cGUYASABKA4yGi5saWxiYXR0bGUudjEuQ3Jvc3NpbmdUeXBlEhMKC2Nvbm5lY3RzX3RvGAIgAygIIoYBCgRUaWxlEgkKAXEYASABKAUSCQoBchgCIAEoBRIRCgl0aWxlX3R5cGUYAyABKAUSDgoGcGxheWVyGAQgASgFEhAKCHNob3J0Y3V0GAUgASgJEhcKD2xhc3RfYWN0ZWRfdHVybhgGIAEoBRIaChJsYXN0X3RvcHBlZHVwX3R1cm4YByABKAUi4wIKBFVuaXQSCQoBcRgBIAEoBRIJCgFyGAIgASgFEg4KBnBsYXllchgDIAEoBRIRCgl1bml0X3R5cGUYBCABKAUSEAoIc2hvcnRjdXQYBSABKAkSGAoQYXZhaWxhYmxlX2hlYWx0aBgGIAEoBRIVCg1kaXN0YW5jZV9sZWZ0GAcgASgBEhcKD2xhc3RfYWN0ZWRfdHVybhgIIAEoBRIaChJsYXN0X3RvcHBlZHVwX3R1cm4YCSABKAUSIgoaYXR0YWNrc19yZWNlaXZlZF90aGlzX3R1cm4YCiABKAUSMgoOYXR0YWNrX2hpc3RvcnkYCyADKAsyGi5saWxiYXR0bGUudjEuQXR0YWNrUmVjb3JkEhgKEHByb2dyZXNzaW9uX3N0ZXAYDCABKAUSGgoSY2hvc2VuX2FsdGVybmF0aXZlGA0gASgJEhwKFGNhcHR1cmVfc3RhcnRlZF90dXJuGA4gASgFIkwKDEF0dGFja1JlY29yZBIJCgFxGAEgASgFEgkKAXIYAiABKAUSEQoJaXNfcmFuZ2VkGAMgASgIEhMKC3R1cm5fbnVtYmVyGAQgASgFIq8CChFUZXJyYWluRGVmaW5pdGlvbhIKCgJpZBgBIAEoBRIMCgRuYW1lGAIgASgJEgwKBHR5cGUYBSABKAUSEwoLZGVzY3JpcHRpb24YBiABKAkSTAoPdW5pdF9wcm9wZXJ0aWVzGAcgAygLMjMubGlsYmF0dGxlLnYxLlRlcnJhaW5EZWZpbml0aW9uLlVuaXRQcm9wZXJ0aWVzRW50cnkSGgoSYnVpbGRhYmxlX3VuaXRfaWRzGAggAygFEhcKD2luY29tZV9wZXJfdHVybhgJIAEoBRpaChNVbml0UHJvcGVydGllc0VudHJ5EgsKA2tleRgBIAEoBRIyCgV2YWx1ZRgCIAEoCzIjLmxpbGJhdHRsZS52MS5UZXJyYWluVW5pdFByb3BlcnRpZXM6AjgBIvoFCg5Vbml0RGVmaW5pdGlvbhIKCgJpZBgBIAEoBRIMCgRuYW1lGAIgASgJEhMKC2Rlc2NyaXB0aW9uGAMgASgJEg4KBmhlYWx0aBgEIAEoBRINCgVjb2lucxgFIAEoBRIXCg9tb3ZlbWVudF9wb2ludHMYBiABKAESFgoOcmV0cmVhdF9wb2ludHMYByABKAESDwoHZGVmZW5zZRgIIAEoBRIUCgxhdHRhY2tfcmFuZ2UYCSABKAUSGAoQbWluX2F0dGFja19yYW5nZRgKIAEoBRIVCg1zcGxhc2hfZGFtYWdlGAsgASgFEk8KEnRlcnJhaW5fcHJvcGVydGllcxgMIAMoCzIzLmxpbGJhdHRsZS52MS5Vbml0RGVmaW5pdGlvbi5UZXJyYWluUHJvcGVydGllc0VudHJ5EhIKCnByb3BlcnRpZXMYDSADKAkSEgoKdW5pdF9jbGFzcxgOIAEoCRIUCgx1bml0X3RlcnJhaW4YDyABKAkSSAoPYXR0YWNrX3ZzX2NsYXNzGBAgAygLMi8ubGlsYmF0dGxlLnYxLlVuaXREZWZpbml0aW9uLkF0dGFja1ZzQ2xhc3NFbnRyeRIUCgxhY3Rpb25fb3JkZXIYESADKAkSRQoNYWN0aW9uX2xpbWl0cxgSIAMoCzIuLmxpbGJhdHRsZS52MS5Vbml0RGVmaW5pdGlvbi5BY3Rpb25MaW1pdHNFbnRyeRIRCglmaXhfdmFsdWUYEyABKAUaXQoWVGVycmFpblByb3BlcnRpZXNFbnRyeRILCgNrZXkYASABKAUSMgoFdmFsdWUYAiABKAsyIy5saWxiYXR0bGUudjEuVGVycmFpblVuaXRQcm9wZXJ0aWVzOgI4ARo0ChJBdHRhY2tWc0NsYXNzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgFOgI4ARozChFBY3Rpb25MaW1pdHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAU6AjgBIu8BChVUZXJyYWluVW5pdFByb3BlcnRpZXMSEgoKdGVycmFpbl9pZBgBIAEoBRIPCgd1bml0X2lkGAIgASgFEhUKDW1vdmVtZW50X2Nvc3QYAyABKAESFQoNaGVhbGluZ19ib251cxgEIAEoBRIRCgljYW5fYnVpbGQYBSABKAgSEwoLY2FuX2NhcHR1cmUYBiABKAgSFAoMYXR0YWNrX2JvbnVzGAcgASgFEhUKDWRlZmVuc2VfYm9udXMYCCABKAUSFAoMYXR0YWNrX3JhbmdlGAkgASgFEhgKEG1pbl9hdHRhY2tfcmFuZ2UYCiABKAUi1gEKElVuaXRVbml0UHJvcGVydGllcxITCgthdHRhY2tlcl9pZBgBIAEoBRITCgtkZWZlbmRlcl9pZBgCIAEoBRIcCg9hdHRhY2tfb3ZlcnJpZGUYAyABKAVIAIgBARIdChBkZWZlbnNlX292ZXJyaWRlGAQgASgFSAGIAQESMAoGZGFtYWdlGAUgASgLMiAubGlsYmF0dGxlLnYxLkRhbWFnZURpc3RyaWJ1dGlvbkISChBfYXR0YWNrX292ZXJyaWRlQhMKEV9kZWZlbnNlX292ZXJyaWRlIoABChJEYW1hZ2VEaXN0cmlidXRpb24SEgoKbWluX2RhbWFnZRgBIAEoARISCgptYXhfZGFtYWdlGAIgASgBEhcKD2V4cGVjdGVkX2RhbWFnZRgDIAEoARIpCgZyYW5nZXMYBCADKAsyGS5saWxiYXR0bGUudjEuRGFtYWdlUmFuZ2UiSAoLRGFtYWdlUmFuZ2USEQoJbWluX3ZhbHVlGAEgASgBEhEKCW1heF92YWx1ZRgCIAEoARITCgtwcm9iYWJpbGl0eRgDIAEoASKXBgoLUnVsZXNFbmdpbmUSMwoFdW5pdHMYASADKAsyJC5saWxiYXR0bGUudjEuUnVsZXNFbmdpbmUuVW5pdHNFbnRyeRI5Cgh0ZXJyYWlucxgCIAMoCzInLmxpbGJhdHRsZS52MS5SdWxlc0VuZ2luZS5UZXJyYWluc0VudHJ5ElUKF3RlcnJhaW5fdW5pdF9wcm9wZXJ0aWVzGAMgAygLMjQubGlsYmF0dGxlLnYxLlJ1bGVzRW5naW5lLlRlcnJhaW5Vbml0UHJvcGVydGllc0VudHJ5Ek8KFHVuaXRfdW5pdF9wcm9wZXJ0aWVzGAQgAygLMjEubGlsYmF0dGxlLnYxLlJ1bGVzRW5naW5lLlVuaXRVbml0UHJvcGVydGllc0VudHJ5EkIKDXRlcnJhaW5fdHlwZXMYBSADKAsyKy5saWxiYXR0bGUudjEuUnVsZXNFbmdpbmUuVGVycmFpblR5cGVzRW50cnkaSgoKVW5pdHNFbnRyeRILCgNrZXkYASABKAUSKwoFdmFsdWUYAiABKAsyHC5saWxiYXR0bGUudjEuVW5pdERlZmluaXRpb246AjgBGlAKDVRlcnJhaW5zRW50cnkSCwoDa2V5GAEgASgFEi4KBXZhbHVlGAIgASgLMh8ubGlsYmF0dGxlLnYxLlRlcnJhaW5EZWZpbml0aW9uOgI4ARphChpUZXJyYWluVW5pdFByb3BlcnRpZXNFbnRyeRILCgNrZXkYASABKAkSMgoFdmFsdWUYAiABKAsyIy5saWxiYXR0bGUudjEuVGVycmFpblVuaXRQcm9wZXJ0aWVzOgI4ARpbChdVbml0VW5pdFByb3BlcnRpZXNFbnRyeRILCgNrZXkYASABKAkSLwoFdmFsdWUYAiABKAsyIC5saWxiYXR0bGUudjEuVW5pdFVuaXRQcm9wZXJ0aWVzOgI4ARpOChFUZXJyYWluVHlwZXNFbnRyeRILCgNrZXkYASABKAUSKAoFdmFsdWUYAiABKA4yGS5saWxiYXR0bGUudjEuVGVycmFpblR5cGU6AjgBIvwCCgRHYW1lEi4KCmNyZWF0ZWRfYXQYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCnVwZGF0ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg8KB3ZlcnNpb24YAyABKAMSCgoCaWQYBCABKAkSEgoKY3JlYXRvcl9pZBgFIAEoCRIQCgh3b3JsZF9pZBgGIAEoCRIMCgRuYW1lGAcgASgJEhMKC2Rlc2NyaXB0aW9uGAggASgJEgwKBHRhZ3MYCSADKAkSEQoJaW1hZ2VfdXJsGAogASgJEhIKCmRpZmZpY3VsdHkYCyABKAkSLwoGY29uZmlnGAwgASgLMh8ubGlsYmF0dGxlLnYxLkdhbWVDb25maWd1cmF0aW9uEhQKDHByZXZpZXdfdXJscxgNIAMoCRIyChFzZWFyY2hfaW5kZXhfaW5mbxgPIAEoCzIXLmxpbGJhdHRsZS52MS5JbmRleEluZm8ixwEKEUdhbWVDb25maWd1cmF0aW9uEikKB3BsYXllcnMYASADKAsyGC5saWxiYXR0bGUudjEuR2FtZVBsYXllchIlCgV0ZWFtcxgCIAMoCzIWLmxpbGJhdHRsZS52MS5HYW1lVGVhbRIyCg5pbmNvbWVfY29uZmlncxgDIAEoCzIaLmxpbGJhdHRsZS52MS5JbmNvbWVDb25maWcSLAoIc2V0dGluZ3MYBCABKAsyGi5saWxiYXR0bGUudjEuR2FtZVNldHRpbmdzIrwBCgxJbmNvbWVDb25maWcSFgoOc3RhcnRpbmdfY29pbnMYASABKAUSEwoLZ2FtZV9pbmNvbWUYAiABKAUSFwoPbGFuZGJhc2VfaW5jb21lGAMgASgFEhgKEG5hdmFsYmFzZV9pbmNvbWUYBCABKAUSGgoSYWlycG9ydGJhc2VfaW5jb21lGAUgASgFEhoKEm1pc3NpbGVzaWxvX2luY29tZRgGIAEoBRIUCgxtaW5lc19pbmNvbWUYByABKAUingEKCkdhbWVQbGF5ZXISEQoJcGxheWVyX2lkGAEgASgFEg8KB3VzZXJfaWQYAiABKAkSEwoLcGxheWVyX3R5cGUYAyABKAkSDQoFY29sb3IYBCABKAkSDwoHdGVhbV9pZBgFIAEoBRIMCgRuYW1lGAYgASgJEhEKCWlzX2FjdGl2ZRgHIAEoCBIWCg5zdGFydGluZ19jb2lucxgIIAEoBSJLCghHYW1lVGVhbRIPCgd0ZWFtX2lkGAEgASgFEgwKBG5hbWUYAiABKAkSDQoFY29sb3IYAyABKAkSEQoJaXNfYWN0aXZlGAQgASgIImQKDEdhbWVTZXR0aW5ncxIVCg1hbGxvd2VkX3VuaXRzGAEgAygFEhcKD3R1cm5fdGltZV9saW1pdBgCIAEoBRIRCgl0ZWFtX21vZGUYAyABKAkSEQoJbWF4X3R1cm5zGAQgASgFIi8KC1BsYXllclN0YXRlEg0KBWNvaW5zGAEgASgFEhEKCWlzX2FjdGl2ZRgCIAEoCCLmAwoJR2FtZVN0YXRlEi4KCnVwZGF0ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg8KB2dhbWVfaWQYAyABKAkSFAoMdHVybl9jb3VudGVyGAQgASgFEhYKDmN1cnJlbnRfcGxheWVyGAUgASgFEisKCndvcmxkX2RhdGEYBiABKAsyFy5saWxiYXR0bGUudjEuV29ybGREYXRhEhIKCnN0YXRlX2hhc2gYCCABKAkSDwoHdmVyc2lvbhgJIAEoAxIoCgZzdGF0dXMYCiABKA4yGC5saWxiYXR0bGUudjEuR2FtZVN0YXR1cxIQCghmaW5pc2hlZBgLIAEoCBIWCg53aW5uaW5nX3BsYXllchgMIAEoBRIUCgx3aW5uaW5nX3RlYW0YDSABKAUSHAoUY3VycmVudF9ncm91cF9udW1iZXIYDiABKAMSQAoNcGxheWVyX3N0YXRlcxgPIAMoCzIpLmxpbGJhdHRsZS52MS5HYW1lU3RhdGUuUGxheWVyU3RhdGVzRW50cnkaTgoRUGxheWVyU3RhdGVzRW50cnkSCwoDa2V5GAEgASgFEigKBXZhbHVlGAIgASgLMhkubGlsYmF0dGxlLnYxLlBsYXllclN0YXRlOgI4ASJPCg9HYW1lTW92ZUhpc3RvcnkSDwoHZ2FtZV9pZBgBIAEoCRIrCgZncm91cHMYAiADKAsyGy5saWxiYXR0bGUudjEuR2FtZU1vdmVHcm91cCKqAQoNR2FtZU1vdmVHcm91cBIuCgpzdGFydGVkX2F0GAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIsCghlbmRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASFAoMZ3JvdXBfbnVtYmVyGAQgASgDEiUKBW1vdmVzGAUgAygLMhYubGlsYmF0dGxlLnYxLkdhbWVNb3ZlIuMECghHYW1lTW92ZRIOCgZwbGF5ZXIYASABKAUSFAoMZ3JvdXBfbnVtYmVyGAIgASgDEhMKC21vdmVfbnVtYmVyGAMgASgDEi0KCXRpbWVzdGFtcBgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMQoJbW92ZV91bml0GAUgASgLMhwubGlsYmF0dGxlLnYxLk1vdmVVbml0QWN0aW9uSAASNQoLYXR0YWNrX3VuaXQYBiABKAsyHi5saWxiYXR0bGUudjEuQXR0YWNrVW5pdEFjdGlvbkgAEi8KCGVuZF90dXJuGAcgASgLMhsubGlsYmF0dGxlLnYxLkVuZFR1cm5BY3Rpb25IABIzCgpidWlsZF91bml0GAggASgLMh0ubGlsYmF0dGxlLnYxLkJ1aWxkVW5pdEFjdGlvbkgAEj8KEGNhcHR1cmVfYnVpbGRpbmcYDSABKAsyIy5saWxiYXR0bGUudjEuQ2FwdHVyZUJ1aWxkaW5nQWN0aW9uSAASMQoJaGVhbF91bml0GA4gASgLMhwubGlsYmF0dGxlLnYxLkhlYWxVbml0QWN0aW9uSAASLwoIZml4X3VuaXQYDyABKAsyGy5saWxiYXR0bGUudjEuRml4VW5pdEFjdGlvbkgAEhQKDHNlcXVlbmNlX251bRgJIAEoAxIUCgxpc19wZXJtYW5lbnQYCiABKAgSKgoHY2hhbmdlcxgLIAMoCzIZLmxpbGJhdHRsZS52MS5Xb3JsZENoYW5nZRITCgtkZXNjcmlwdGlvbhgMIAEoCUILCgltb3ZlX3R5cGUiLwoIUG9zaXRpb24SDQoFbGFiZWwYASABKAkSCQoBcRgCIAEoBRIJCgFyGAMgASgFIqEBCg5Nb3ZlVW5pdEFjdGlvbhIkCgRmcm9tGAEgASgLMhYubGlsYmF0dGxlLnYxLlBvc2l0aW9uEiIKAnRvGAIgASgLMhYubGlsYmF0dGxlLnYxLlBvc2l0aW9uEhUKDW1vdmVtZW50X2Nvc3QYAyABKAESLgoScmVjb25zdHJ1Y3RlZF9wYXRoGAQgASgLMhIubGlsYmF0dGxlLnYxLlBhdGgiyQEKEEF0dGFja1VuaXRBY3Rpb24SKAoIYXR0YWNrZXIYASABKAsyFi5saWxiYXR0bGUudjEuUG9zaXRpb24SKAoIZGVmZW5kZXIYAiABKAsyFi5saWxiYXR0bGUudjEuUG9zaXRpb24SGAoQdGFyZ2V0X3VuaXRfdHlwZRgHIAEoBRIaChJ0YXJnZXRfdW5pdF9oZWFsdGgYCCABKAUSEgoKY2FuX2F0dGFjaxgJIAEoCBIXCg9kYW1hZ2VfZXN0aW1hdGUYCiABKAUiVwoPQnVpbGRVbml0QWN0aW9uEiMKA3BvcxgBIAEoCzIWLmxpbGJhdHRsZS52MS5Qb3NpdGlvbhIRCgl1bml0X3R5cGUYAiABKAUSDAoEY29zdBgDIAEoBSJPChVDYXB0dXJlQnVpbGRpbmdBY3Rpb24SIwoDcG9zGAEgASgLMhYubGlsYmF0dGxlLnYxLlBvc2l0aW9uEhEKCXRpbGVfdHlwZRgDIAEoBSIPCg1FbmRUdXJuQWN0aW9uIkoKDkhlYWxVbml0QWN0aW9uEiMKA3BvcxgBIAEoCzIWLmxpbGJhdHRsZS52MS5Qb3NpdGlvbhITCgtoZWFsX2Ftb3VudBgCIAEoBSJyCg1GaXhVbml0QWN0aW9uEiUKBWZpeGVyGAEgASgLMhYubGlsYmF0dGxlLnYxLlBvc2l0aW9uEiYKBnRhcmdldBgCIAEoCzIWLmxpbGJhdHRsZS52MS5Qb3NpdGlvbhISCgpmaXhfYW1vdW50GAMgASgFItQECgtXb3JsZENoYW5nZRIzCgp1bml0X21vdmVkGAEgASgLMh0ubGlsYmF0dGxlLnYxLlVuaXRNb3ZlZENoYW5nZUgAEjcKDHVuaXRfZGFtYWdlZBgCIAEoCzIfLmxpbGJhdHRsZS52MS5Vbml0RGFtYWdlZENoYW5nZUgAEjUKC3VuaXRfa2lsbGVkGAMgASgLMh4ubGlsYmF0dGxlLnYxLlVuaXRLaWxsZWRDaGFuZ2VIABI7Cg5wbGF5ZXJfY2hhbmdlZBgEIAEoCzIhLmxpbGJhdHRsZS52MS5QbGF5ZXJDaGFuZ2VkQ2hhbmdlSAASMwoKdW5pdF9idWlsdBgFIAEoCzIdLmxpbGJhdHRsZS52MS5Vbml0QnVpbHRDaGFuZ2VIABI5Cg1jb2luc19jaGFuZ2VkGAYgASgLMiAubGlsYmF0dGxlLnYxLkNvaW5zQ2hhbmdlZENoYW5nZUgAEjkKDXRpbGVfY2FwdHVyZWQYByABKAsyIC5saWxiYXR0bGUudjEuVGlsZUNhcHR1cmVkQ2hhbmdlSAASPQoPY2FwdHVyZV9zdGFydGVkGAggASgLMiIubGlsYmF0dGxlLnYxLkNhcHR1cmVTdGFydGVkQ2hhbmdlSAASNQoLdW5pdF9oZWFsZWQYCSABKAsyHi5saWxiYXR0bGUudjEuVW5pdEhlYWxlZENoYW5nZUgAEjMKCnVuaXRfZml4ZWQYCiABKAsyHS5saWxiYXR0bGUudjEuVW5pdEZpeGVkQ2hhbmdlSABCDQoLY2hhbmdlX3R5cGUifAoQVW5pdEhlYWxlZENoYW5nZRIpCg1wcmV2aW91c191bml0GAEgASgLMhIubGlsYmF0dGxlLnYxLlVuaXQSKAoMdXBkYXRlZF91bml0GAIgASgLMhIubGlsYmF0dGxlLnYxLlVuaXQSEwoLaGVhbF9hbW91bnQYAyABKAUipgEKD1VuaXRGaXhlZENoYW5nZRImCgpmaXhlcl91bml0GAEgASgLMhIubGlsYmF0dGxlLnYxLlVuaXQSKwoPcHJldmlvdXNfdGFyZ2V0GAIgASgLMhIubGlsYmF0dGxlLnYxLlVuaXQSKgoOdXBkYXRlZF90YXJnZXQYAyABKAsyEi5saWxiYXR0bGUudjEuVW5pdBISCgpmaXhfYW1vdW50GAQgASgFImYKD1VuaXRNb3ZlZENoYW5nZRIpCg1wcmV2aW91c191bml0GAYgASgLMhIubGlsYmF0dGxlLnYxLlVuaXQSKAoMdXBkYXRlZF91bml0GAcgASgLMhIubGlsYmF0dGxlLnYxLlVuaXQiaAoRVW5pdERhbWFnZWRDaGFuZ2USKQoNcHJldmlvdXNfdW5pdBgGIAEoCzISLmxpbGJhdHRsZS52MS5Vbml0EigKDHVwZGF0ZWRfdW5pdBgHIAEoCzISLmxpbGJhdHRsZS52MS5Vbml0Ij0KEFVuaXRLaWxsZWRDaGFuZ2USKQoNcHJldmlvdXNfdW5pdBgGIAEoCzISLmxpbGJhdHRsZS52MS5Vbml0IpQBChNQbGF5ZXJDaGFuZ2VkQ2hhbmdlEhcKD3ByZXZpb3VzX3BsYXllchgBIAEoBRISCgpuZXdfcGxheWVyGAIgASgFEhUKDXByZXZpb3VzX3R1cm4YAyABKAUSEAoIbmV3X3R1cm4YBCABKAUSJwoLcmVzZXRfdW5pdHMYBSADKAsyEi5saWxiYXR0bGUudjEuVW5pdCJ9Cg9Vbml0QnVpbHRDaGFuZ2USIAoEdW5pdBgBIAEoCzISLmxpbGJhdHRsZS52MS5Vbml0Eg4KBnRpbGVfcRgCIAEoBRIOCgZ0aWxlX3IYAyABKAUSEgoKY29pbnNfY29zdBgEIAEoBRIUCgxwbGF5ZXJfY29pbnMYBSABKAUiYgoSQ29pbnNDaGFuZ2VkQ2hhbmdlEhEKCXBsYXllcl9pZBgBIAEoBRIWCg5wcmV2aW91c19jb2lucxgCIAEoBRIRCgluZXdfY29pbnMYAyABKAUSDgoGcmVhc29uGAQgASgJIp4BChJUaWxlQ2FwdHVyZWRDaGFuZ2USKgoOY2FwdHVyaW5nX3VuaXQYASABKAsyEi5saWxiYXR0bGUudjEuVW5pdBIOCgZ0aWxlX3EYAiABKAUSDgoGdGlsZV9yGAMgASgFEhEKCXRpbGVfdHlwZRgEIAEoBRIWCg5wcmV2aW91c19vd25lchgFIAEoBRIRCgluZXdfb3duZXIYBiABKAUijAEKFENhcHR1cmVTdGFydGVkQ2hhbmdlEioKDmNhcHR1cmluZ191bml0GAEgASgLMhIubGlsYmF0dGxlLnYxLlVuaXQSDgoGdGlsZV9xGAIgASgFEg4KBnRpbGVfchgDIAEoBRIRCgl0aWxlX3R5cGUYBCABKAUSFQoNY3VycmVudF9vd25lchgFIAEoBSKmAQoIQWxsUGF0aHMSEAoIc291cmNlX3EYASABKAUSEAoIc291cmNlX3IYAiABKAUSMAoFZWRnZXMYAyADKAsyIS5saWxiYXR0bGUudjEuQWxsUGF0aHMuRWRnZXNFbnRyeRpECgpFZGdlc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmxpbGJhdHRsZS52MS5QYXRoRWRnZToCOAEisQEKCFBhdGhFZGdlEg4KBmZyb21fcRgBIAEoBRIOCgZmcm9tX3IYAiABKAUSDAoEdG9fcRgDIAEoBRIMCgR0b19yGAQgASgFEhUKDW1vdmVtZW50X2Nvc3QYBSABKAESEgoKdG90YWxfY29zdBgGIAEoARIUCgx0ZXJyYWluX3R5cGUYByABKAkSEwoLZXhwbGFuYXRpb24YCCABKAkSEwoLaXNfb2NjdXBpZWQYCSABKAgicgoEUGF0aBIlCgVlZGdlcxgBIAMoCzIWLmxpbGJhdHRsZS52MS5QYXRoRWRnZRIvCgpkaXJlY3Rpb25zGAIgAygOMhsubGlsYmF0dGxlLnYxLlBhdGhEaXJlY3Rpb24SEgoKdG90YWxfY29zdBgDIAEoASpfCgxDcm9zc2luZ1R5cGUSHQoZQ1JPU1NJTkdfVFlQRV9VTlNQRUNJRklFRBAAEhYKEkNST1NTSU5HX1RZUEVfUk9BRBABEhgKFENST1NTSU5HX1RZUEVfQlJJREdFEAIqowEKC1RlcnJhaW5UeXBlEhwKGFRFUlJBSU5fVFlQRV9VTlNQRUNJRklFRBAAEhUKEVRFUlJBSU5fVFlQRV9DSVRZEAESFwoTVEVSUkFJTl9UWVBFX05BVFVSRRACEhcKE1RFUlJBSU5fVFlQRV9CUklER0UQAxIWChJURVJSQUlOX1RZUEVfV0FURVIQBBIVChFURVJSQUlOX1RZUEVfUk9BRBAFKnEKCkdhbWVTdGF0dXMSGwoXR0FNRV9TVEFUVVNfVU5TUEVDSUZJRUQQABIXChNHQU1FX1NUQVRVU19QTEFZSU5HEAESFgoSR0FNRV9TVEFUVVNfUEFVU0VEEAISFQoRR0FNRV9TVEFUVVNfRU5ERUQQAyreAQoNUGF0aERpcmVjdGlvbhIeChpQQVRIX0RJUkVDVElPTl9VTlNQRUNJRklFRBAAEhcKE1BBVEhfRElSRUNUSU9OX0xFRlQQARIbChdQQVRIX0RJUkVDVElPTl9UT1BfTEVGVBACEhwKGFBBVEhfRElSRUNUSU9OX1RPUF9SSUdIVBADEhgKFFBBVEhfRElSRUNUSU9OX1JJR0hUEAQSHwobUEFUSF9ESVJFQ1RJT05fQk9UVE9NX1JJR0hUEAUSHgoaUEFUSF9ESVJFQ1RJT05fQk9UVE9NX0xFRlQQBkK3AQoQY29tLmxpbGJhdHRsZS52MUILTW9kZWxzUHJvdG9QAVpFZ2l0aHViLmNvbS90dXJuZm9yZ2UvbGlsYmF0dGxlL2dlbi9nby9saWxiYXR0bGUvdjEvbW9kZWxzO2xpbGJhdHRsZXYxogIDTFhYqgIMTGlsYmF0dGxlLlYxygIMTGlsYmF0dGxlXFYx4gIYTGlsYmF0dGxlXFYxXEdQQk1ldGFkYXRh6gINTGlsYmF0dGxlOjpWMWIGcHJvdG8z", [file_google_protobuf_timestamp, file_google_protobuf_struct]);

/**
 * @generated from message lilbattle.v1.IndexInfo
 */
export type IndexInfo = Message<"lilbattle.v1.IndexInfo"> & {
  /**
   * We maintain an IndexInfo for each type of "indexing" operation needed
   * For example one update may change the keywords (so we need to update indexes for search)
   * Another might update the "units" so we may need a new screenshot
   * Each one's updates - updated and indexed timestamps separately so they can be tracked sepately
   *
   * @generated from field: google.protobuf.Timestamp last_updated_at = 1;
   */
  lastUpdatedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_indexed_at = 2;
   */
  lastIndexedAt?: Timestamp;

  /**
   * @generated from field: bool needs_indexing = 3;
   */
  needsIndexing: boolean;
};

/**
 * Describes the message lilbattle.v1.IndexInfo.
 * Use `create(IndexInfoSchema)` to create a new message.
 */
export const IndexInfoSchema: GenMessage<IndexInfo> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 0);

/**
 * @generated from message lilbattle.v1.Pagination
 */
export type Pagination = Message<"lilbattle.v1.Pagination"> & {
  /**
   * *
   * Instead of an offset an abstract  "page" key is provided that offers
   * an opaque "pointer" into some offset in a result set.
   *
   * @generated from field: string page_key = 1;
   */
  pageKey: string;

  /**
   * *
   * If a pagekey is not supported we can also support a direct integer offset
   * for cases where it makes sense.
   *
   * @generated from field: int32 page_offset = 2;
   */
  pageOffset: number;

  /**
   * *
   * Number of results to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;
};

/**
 * Describes the message lilbattle.v1.Pagination.
 * Use `create(PaginationSchema)` to create a new message.
 */
export const PaginationSchema: GenMessage<Pagination> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 1);

/**
 * @generated from message lilbattle.v1.PaginationResponse
 */
export type PaginationResponse = Message<"lilbattle.v1.PaginationResponse"> & {
  /**
   * *
   * The key/pointer string that subsequent List requests should pass to
   * continue the pagination.
   *
   * @generated from field: string next_page_key = 2;
   */
  nextPageKey: string;

  /**
   * *
   * Also support an integer offset if possible
   *
   * @generated from field: int32 next_page_offset = 3;
   */
  nextPageOffset: number;

  /**
   * *
   * Whether theere are more results.
   *
   * @generated from field: bool has_more = 4;
   */
  hasMore: boolean;

  /**
   * *
   * Total number of results.
   *
   * @generated from field: int32 total_results = 5;
   */
  totalResults: number;
};

/**
 * Describes the message lilbattle.v1.PaginationResponse.
 * Use `create(PaginationResponseSchema)` to create a new message.
 */
export const PaginationResponseSchema: GenMessage<PaginationResponse> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 2);

/**
 * @generated from message lilbattle.v1.World
 */
export type World = Message<"lilbattle.v1.World"> & {
  /**
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * Version for Optimistic concurrent locking
   *
   * @generated from field: int64 version = 3;
   */
  version: bigint;

  /**
   * Unique ID for the world
   *
   * @generated from field: string id = 4;
   */
  id: string;

  /**
   * User that created the world
   *
   * @generated from field: string creator_id = 5;
   */
  creatorId: string;

  /**
   * Name if items have names
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * Description if world has a description
   *
   * @generated from field: string description = 7;
   */
  description: string;

  /**
   * Some tags
   *
   * @generated from field: repeated string tags = 8;
   */
  tags: string[];

  /**
   * A possible image url
   *
   * @generated from field: string image_url = 9;
   */
  imageUrl: string;

  /**
   * Difficulty - example attribute
   *
   * @generated from field: string difficulty = 10;
   */
  difficulty: string;

  /**
   * URL to screenshot/preview image (defaults to /worlds/{id}/screenshots/{screenshotName})
   * Can be overridden to point to CDN or external hosting
   *
   * @generated from field: repeated string preview_urls = 11;
   */
  previewUrls: string[];

  /**
   * Default game configs
   *
   * @generated from field: lilbattle.v1.GameConfiguration default_game_config = 12;
   */
  defaultGameConfig?: GameConfiguration;

  /**
   * @generated from field: lilbattle.v1.IndexInfo search_index_info = 13;
   */
  searchIndexInfo?: IndexInfo;
};

/**
 * Describes the message lilbattle.v1.World.
 * Use `create(WorldSchema)` to create a new message.
 */
export const WorldSchema: GenMessage<World> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 3);

/**
 * @generated from message lilbattle.v1.WorldData
 */
export type WorldData = Message<"lilbattle.v1.WorldData"> & {
  /**
   * New map-based storage (key = "q,r" coordinate string)
   *
   * @generated from field: map<string, lilbattle.v1.Tile> tiles_map = 1;
   */
  tilesMap: { [key: string]: Tile };

  /**
   * @generated from field: map<string, lilbattle.v1.Unit> units_map = 2;
   */
  unitsMap: { [key: string]: Unit };

  /**
   * When this world data was updated (may have happened without world updating)
   *
   * @generated from field: lilbattle.v1.IndexInfo screenshot_index_info = 3;
   */
  screenshotIndexInfo?: IndexInfo;

  /**
   * We will only update if hash's are different
   *
   * @generated from field: string content_hash = 4;
   */
  contentHash: string;

  /**
   * Version for Optimistic concurrent locking
   *
   * @generated from field: int64 version = 5;
   */
  version: bigint;

  /**
   * Improvement layer - crossings (roads on land, bridges on water)
   *
   * key = "q,r", value = crossing with connectivity
   *
   * @generated from field: map<string, lilbattle.v1.Crossing> crossings = 8;
   */
  crossings: { [key: string]: Crossing };
};

/**
 * Describes the message lilbattle.v1.WorldData.
 * Use `create(WorldDataSchema)` to create a new message.
 */
export const WorldDataSchema: GenMessage<WorldData> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 4);

/**
 * Crossing with explicit connectivity data
 * Each crossing stores which of its 6 hex neighbors it connects to
 *
 * @generated from message lilbattle.v1.Crossing
 */
export type Crossing = Message<"lilbattle.v1.Crossing"> & {
  /**
   * @generated from field: lilbattle.v1.CrossingType type = 1;
   */
  type: CrossingType;

  /**
   * 6 booleans for hex neighbors in order matching AxialNeighborDeltas:
   * 0: LEFT (-1,0), 1: TOP_LEFT (0,-1), 2: TOP_RIGHT (1,-1),
   * 3: RIGHT (1,0), 4: BOTTOM_RIGHT (0,1), 5: BOTTOM_LEFT (-1,1)
   *
   * @generated from field: repeated bool connects_to = 2;
   */
  connectsTo: boolean[];
};

/**
 * Describes the message lilbattle.v1.Crossing.
 * Use `create(CrossingSchema)` to create a new message.
 */
export const CrossingSchema: GenMessage<Crossing> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 5);

/**
 * @generated from message lilbattle.v1.Tile
 */
export type Tile = Message<"lilbattle.v1.Tile"> & {
  /**
   * Q and R in Cubed coordinates
   *
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * Tile type
   *
   * @generated from field: int32 tile_type = 3;
   */
  tileType: number;

  /**
   * Whether the tile itself belongs to a player
   *
   * @generated from field: int32 player = 4;
   */
  player: number;

  /**
   * A short cut like A1 or S2 etc for quick access
   *
   * @generated from field: string shortcut = 5;
   */
  shortcut: string;

  /**
   * Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
   * This helps us not having to "top up" or "reset" the stats at the end
   * of each turn.  Instead as the game turn is incremented we can do a 
   * lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
   * So we just have to increment the game_turn and the unit is automaticaly flagged as
   * needing a top up of its health/balance/movement etc
   *
   * Which turn this unit was created/last acted on (ie movemade)
   *
   * @generated from field: int32 last_acted_turn = 6;
   */
  lastActedTurn: number;

  /**
   * When the last top up happened
   *
   * @generated from field: int32 last_toppedup_turn = 7;
   */
  lastToppedupTurn: number;
};

/**
 * Describes the message lilbattle.v1.Tile.
 * Use `create(TileSchema)` to create a new message.
 */
export const TileSchema: GenMessage<Tile> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 6);

/**
 * @generated from message lilbattle.v1.Unit
 */
export type Unit = Message<"lilbattle.v1.Unit"> & {
  /**
   * Q and R in Cubed coordinates
   *
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * @generated from field: int32 player = 3;
   */
  player: number;

  /**
   * @generated from field: int32 unit_type = 4;
   */
  unitType: number;

  /**
   * A short cut like A1 or S2 etc for quick access
   *
   * @generated from field: string shortcut = 5;
   */
  shortcut: string;

  /**
   * Runtime state fields
   *
   * Current health points
   *
   * @generated from field: int32 available_health = 6;
   */
  availableHealth: number;

  /**
   * Movement points remaining this turn
   *
   * @generated from field: double distance_left = 7;
   */
  distanceLeft: number;

  /**
   * Keep track of turns when the move was last made and when a "top up" was last done on/for this tile.
   * This helps us not having to "top up" or "reset" the stats at the end
   * of each turn.  Instead as the game turn is incremented we can do a 
   * lazy reset for any unit or tile where unit_or_tile.last_toppedup_turn < game.curent_turn
   * So we just have to increment the game_turn and the unit is automaticaly flagged as
   * needing a top up of its health/balance/movement etc
   *
   * Which turn this unit was created/last acted on (ie movemade)
   *
   * @generated from field: int32 last_acted_turn = 8;
   */
  lastActedTurn: number;

  /**
   * When the last top up happened
   *
   * @generated from field: int32 last_toppedup_turn = 9;
   */
  lastToppedupTurn: number;

  /**
   * Details around wound bonus tracking for this turn
   *
   * Total number of attacks received this turn
   *
   * @generated from field: int32 attacks_received_this_turn = 10;
   */
  attacksReceivedThisTurn: number;

  /**
   * Detailed attack history for wound bonus calculation
   *
   * @generated from field: repeated lilbattle.v1.AttackRecord attack_history = 11;
   */
  attackHistory: AttackRecord[];

  /**
   * Action progression tracking - index into UnitDefinition.action_order
   * Indicates which step in the action sequence the unit is currently on
   * Reset to 0 at turn start via TopUpUnitIfNeeded()
   *
   * @generated from field: int32 progression_step = 12;
   */
  progressionStep: number;

  /**
   * When current step has pipe-separated alternatives (e.g., "attack|capture"),
   * this tracks which alternative the user chose, preventing switching mid-step
   * Cleared when advancing to next step
   *
   * @generated from field: string chosen_alternative = 13;
   */
  chosenAlternative: string;

  /**
   * Turn when this unit started capturing a building (0 = not capturing)
   * Capture completes at the start of the capturing player's next turn
   * if the unit is still alive on the tile
   *
   * @generated from field: int32 capture_started_turn = 14;
   */
  captureStartedTurn: number;
};

/**
 * Describes the message lilbattle.v1.Unit.
 * Use `create(UnitSchema)` to create a new message.
 */
export const UnitSchema: GenMessage<Unit> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 7);

/**
 * @generated from message lilbattle.v1.AttackRecord
 */
export type AttackRecord = Message<"lilbattle.v1.AttackRecord"> & {
  /**
   * Attacker's Q coordinate
   *
   * @generated from field: int32 q = 1;
   */
  q: number;

  /**
   * Attacker's R coordinate
   *
   * @generated from field: int32 r = 2;
   */
  r: number;

  /**
   * Whether attacker is ranged 2+ tiles away
   *
   * @generated from field: bool is_ranged = 3;
   */
  isRanged: boolean;

  /**
   * Which turn this attack occured
   *
   * @generated from field: int32 turn_number = 4;
   */
  turnNumber: number;
};

/**
 * Describes the message lilbattle.v1.AttackRecord.
 * Use `create(AttackRecordSchema)` to create a new message.
 */
export const AttackRecordSchema: GenMessage<AttackRecord> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 8);

/**
 * Rules engine terrain definition
 *
 * @generated from message lilbattle.v1.TerrainDefinition
 */
export type TerrainDefinition = Message<"lilbattle.v1.TerrainDefinition"> & {
  /**
   * Terrain type ID
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Display name (e.g., "Grass", "Mountain")  
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * double base_move_cost = 3;     // Base movement cost
   * double defense_bonus = 4;      // Defense bonus multiplier (0.0 to 1.0)
   *
   * Terrain category type
   *
   * @generated from field: int32 type = 5;
   */
  type: number;

  /**
   * Human-readable description
   *
   * @generated from field: string description = 6;
   */
  description: string;

  /**
   * How this terrain impacts 
   *
   * @generated from field: map<int32, lilbattle.v1.TerrainUnitProperties> unit_properties = 7;
   */
  unitProperties: { [key: number]: TerrainUnitProperties };

  /**
   * List of units that can be built on this terrain
   *
   * @generated from field: repeated int32 buildable_unit_ids = 8;
   */
  buildableUnitIds: number[];

  /**
   * @generated from field: int32 income_per_turn = 9;
   */
  incomePerTurn: number;
};

/**
 * Describes the message lilbattle.v1.TerrainDefinition.
 * Use `create(TerrainDefinitionSchema)` to create a new message.
 */
export const TerrainDefinitionSchema: GenMessage<TerrainDefinition> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 9);

/**
 * Rules engine unit definition  
 *
 * @generated from message lilbattle.v1.UnitDefinition
 */
export type UnitDefinition = Message<"lilbattle.v1.UnitDefinition"> & {
  /**
   * Unit type ID
   *
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * Display name (e.g., "Infantry", "Tank")
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Maximum health points
   *
   * @generated from field: int32 health = 4;
   */
  health: number;

  /**
   * how much it costs to build
   *
   * @generated from field: int32 coins = 5;
   */
  coins: number;

  /**
   * Maximum movement per turn
   *
   * @generated from field: double movement_points = 6;
   */
  movementPoints: number;

  /**
   * Movement points available after attacking
   *
   * @generated from field: double retreat_points = 7;
   */
  retreatPoints: number;

  /**
   * Base defense value
   *
   * @generated from field: int32 defense = 8;
   */
  defense: number;

  /**
   * Max Attack range in tiles
   *
   * @generated from field: int32 attack_range = 9;
   */
  attackRange: number;

  /**
   * Minimum attack range in tile radius if specified (otherwise - will be 1
   *
   * @generated from field: int32 min_attack_range = 10;
   */
  minAttackRange: number;

  /**
   * Splash damage amount
   *
   * @generated from field: int32 splash_damage = 11;
   */
  splashDamage: number;

  /**
   * @generated from field: map<int32, lilbattle.v1.TerrainUnitProperties> terrain_properties = 12;
   */
  terrainProperties: { [key: number]: TerrainUnitProperties };

  /**
   * Special properties/abilities
   *
   * @generated from field: repeated string properties = 13;
   */
  properties: string[];

  /**
   * Unit classification for attack calculations
   *
   * "Light", "Heavy", or "Stealth"
   *
   * @generated from field: string unit_class = 14;
   */
  unitClass: string;

  /**
   * "Air", "Land", or "Water"
   *
   * @generated from field: string unit_terrain = 15;
   */
  unitTerrain: string;

  /**
   * Attack table: base attack values against different unit classes
   * Key format: "Light:Air", "Heavy:Land", "Stealth:Water", etc.
   * Value 0 or missing key means "n/a" (cannot attack)
   *
   * @generated from field: map<string, int32> attack_vs_class = 16;
   */
  attackVsClass: { [key: string]: number };

  /**
   * Ordered list of allowed actions this turn
   * Examples:
   *   ["move", "attack"] - can move then attack
   *   ["move", "attack|capture"] - can move then either attack or capture
   *   ["attack"] - can only attack (no movement)
   * Default if empty: ["move", "attack|capture"]
   *
   * @generated from field: repeated string action_order = 17;
   */
  actionOrder: string[];

  /**
   * How many times each action type can be performed per turn
   * Key: action name, Value: max count
   * Example: {"attack": 2} means can attack twice
   * Default if not specified: 1 per action type
   *
   * @generated from field: map<string, int32> action_limits = 18;
   */
  actionLimits: { [key: string]: number };

  /**
   * Fix value for units that can repair other units (Medic, Engineer, etc.)
   * Used in fix calculation: p = 0.05 * fix_value
   * Default 0 means unit cannot fix
   *
   * @generated from field: int32 fix_value = 19;
   */
  fixValue: number;
};

/**
 * Describes the message lilbattle.v1.UnitDefinition.
 * Use `create(UnitDefinitionSchema)` to create a new message.
 */
export const UnitDefinitionSchema: GenMessage<UnitDefinition> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 10);

/**
 * Properties that are specific to unit on a particular terrain
 *
 * @generated from message lilbattle.v1.TerrainUnitProperties
 */
export type TerrainUnitProperties = Message<"lilbattle.v1.TerrainUnitProperties"> & {
  /**
   * Renamed from tile_id for clarity
   *
   * @generated from field: int32 terrain_id = 1;
   */
  terrainId: number;

  /**
   * @generated from field: int32 unit_id = 2;
   */
  unitId: number;

  /**
   * Movement cost for this unit on this terrain
   *
   * @generated from field: double movement_cost = 3;
   */
  movementCost: number;

  /**
   * How much healing per turn this tile would offer this unit
   *
   * @generated from field: int32 healing_bonus = 4;
   */
  healingBonus: number;

  /**
   * Whether this particular terrain can build this given unit
   *
   * @generated from field: bool can_build = 5;
   */
  canBuild: boolean;

  /**
   * Whether this particular unit can capture this terrain/building type
   *
   * @generated from field: bool can_capture = 6;
   */
  canCapture: boolean;

  /**
   * How much more attack this terrain gives to this unit
   *
   * @generated from field: int32 attack_bonus = 7;
   */
  attackBonus: number;

  /**
   * How much more defense this terrain gives to this unit
   *
   * @generated from field: int32 defense_bonus = 8;
   */
  defenseBonus: number;

  /**
   * Max Attack range in tiles
   *
   * @generated from field: int32 attack_range = 9;
   */
  attackRange: number;

  /**
   * Minimum attack range in tile radius if specified (otherwise - will be 1
   *
   * @generated from field: int32 min_attack_range = 10;
   */
  minAttackRange: number;
};

/**
 * Describes the message lilbattle.v1.TerrainUnitProperties.
 * Use `create(TerrainUnitPropertiesSchema)` to create a new message.
 */
export const TerrainUnitPropertiesSchema: GenMessage<TerrainUnitProperties> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 11);

/**
 * Properties for unit-vs-unit combat interactions
 *
 * @generated from message lilbattle.v1.UnitUnitProperties
 */
export type UnitUnitProperties = Message<"lilbattle.v1.UnitUnitProperties"> & {
  /**
   * @generated from field: int32 attacker_id = 1;
   */
  attackerId: number;

  /**
   * @generated from field: int32 defender_id = 2;
   */
  defenderId: number;

  /**
   * Optional attack override for this Attacker/Defender combo
   *
   * @generated from field: optional int32 attack_override = 3;
   */
  attackOverride?: number;

  /**
   * Optional defense override for this Attacker/Defender combo
   *
   * @generated from field: optional int32 defense_override = 4;
   */
  defenseOverride?: number;

  /**
   * @generated from field: lilbattle.v1.DamageDistribution damage = 5;
   */
  damage?: DamageDistribution;
};

/**
 * Describes the message lilbattle.v1.UnitUnitProperties.
 * Use `create(UnitUnitPropertiesSchema)` to create a new message.
 */
export const UnitUnitPropertiesSchema: GenMessage<UnitUnitProperties> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 12);

/**
 * Damage distribution for combat calculations
 *
 * @generated from message lilbattle.v1.DamageDistribution
 */
export type DamageDistribution = Message<"lilbattle.v1.DamageDistribution"> & {
  /**
   * @generated from field: double min_damage = 1;
   */
  minDamage: number;

  /**
   * @generated from field: double max_damage = 2;
   */
  maxDamage: number;

  /**
   * @generated from field: double expected_damage = 3;
   */
  expectedDamage: number;

  /**
   * @generated from field: repeated lilbattle.v1.DamageRange ranges = 4;
   */
  ranges: DamageRange[];
};

/**
 * Describes the message lilbattle.v1.DamageDistribution.
 * Use `create(DamageDistributionSchema)` to create a new message.
 */
export const DamageDistributionSchema: GenMessage<DamageDistribution> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 13);

/**
 * @generated from message lilbattle.v1.DamageRange
 */
export type DamageRange = Message<"lilbattle.v1.DamageRange"> & {
  /**
   * @generated from field: double min_value = 1;
   */
  minValue: number;

  /**
   * @generated from field: double max_value = 2;
   */
  maxValue: number;

  /**
   * @generated from field: double probability = 3;
   */
  probability: number;
};

/**
 * Describes the message lilbattle.v1.DamageRange.
 * Use `create(DamageRangeSchema)` to create a new message.
 */
export const DamageRangeSchema: GenMessage<DamageRange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 14);

/**
 * Main rules engine definition - centralized source of truth
 *
 * @generated from message lilbattle.v1.RulesEngine
 */
export type RulesEngine = Message<"lilbattle.v1.RulesEngine"> & {
  /**
   * Core entity definitions
   *
   * @generated from field: map<int32, lilbattle.v1.UnitDefinition> units = 1;
   */
  units: { [key: number]: UnitDefinition };

  /**
   * @generated from field: map<int32, lilbattle.v1.TerrainDefinition> terrains = 2;
   */
  terrains: { [key: number]: TerrainDefinition };

  /**
   * Centralized property definitions (source of truth)
   * Key format: "terrain_id:unit_id" (e.g., "1:3" for terrain 1, unit 3)
   *
   * @generated from field: map<string, lilbattle.v1.TerrainUnitProperties> terrain_unit_properties = 3;
   */
  terrainUnitProperties: { [key: string]: TerrainUnitProperties };

  /**
   * Key format: "attacker_id:defender_id" (e.g., "1:2" for unit 1 attacking unit 2)
   *
   * @generated from field: map<string, lilbattle.v1.UnitUnitProperties> unit_unit_properties = 4;
   */
  unitUnitProperties: { [key: string]: UnitUnitProperties };

  /**
   * Terrain type classifications (terrain_id -> TerrainType)
   * Used to determine if a terrain is city, nature, bridge, water, or road
   *
   * @generated from field: map<int32, lilbattle.v1.TerrainType> terrain_types = 5;
   */
  terrainTypes: { [key: number]: TerrainType };
};

/**
 * Describes the message lilbattle.v1.RulesEngine.
 * Use `create(RulesEngineSchema)` to create a new message.
 */
export const RulesEngineSchema: GenMessage<RulesEngine> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 15);

/**
 * Describes a game and its metadata
 *
 * @generated from message lilbattle.v1.Game
 */
export type Game = Message<"lilbattle.v1.Game"> & {
  /**
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * Version number for optimistic locking
   *
   * @generated from field: int64 version = 3;
   */
  version: bigint;

  /**
   * Unique ID for the game
   *
   * @generated from field: string id = 4;
   */
  id: string;

  /**
   * User who started/created the game
   *
   * @generated from field: string creator_id = 5;
   */
  creatorId: string;

  /**
   * The world this game was created from
   *
   * @generated from field: string world_id = 6;
   */
  worldId: string;

  /**
   * Name if items have names
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * Description if game has a description
   *
   * @generated from field: string description = 8;
   */
  description: string;

  /**
   * Some tags
   *
   * @generated from field: repeated string tags = 9;
   */
  tags: string[];

  /**
   * A possible image url
   *
   * @generated from field: string image_url = 10;
   */
  imageUrl: string;

  /**
   * Difficulty - example attribute
   *
   * @generated from field: string difficulty = 11;
   */
  difficulty: string;

  /**
   * Game configuration
   *
   * @generated from field: lilbattle.v1.GameConfiguration config = 12;
   */
  config?: GameConfiguration;

  /**
   * URL to screenshot/preview image (defaults to /games/{id}/screenshots/{screenshotName})
   * Can be overridden to point to CDN or external hosting
   *
   * @generated from field: repeated string preview_urls = 13;
   */
  previewUrls: string[];

  /**
   * @generated from field: lilbattle.v1.IndexInfo search_index_info = 15;
   */
  searchIndexInfo?: IndexInfo;
};

/**
 * Describes the message lilbattle.v1.Game.
 * Use `create(GameSchema)` to create a new message.
 */
export const GameSchema: GenMessage<Game> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 16);

/**
 * @generated from message lilbattle.v1.GameConfiguration
 */
export type GameConfiguration = Message<"lilbattle.v1.GameConfiguration"> & {
  /**
   * Player configuration
   *
   * @generated from field: repeated lilbattle.v1.GamePlayer players = 1;
   */
  players: GamePlayer[];

  /**
   * Team configuration
   *
   * @generated from field: repeated lilbattle.v1.GameTeam teams = 2;
   */
  teams: GameTeam[];

  /**
   * Various kinds of per turn income configs
   *
   * @generated from field: lilbattle.v1.IncomeConfig income_configs = 3;
   */
  incomeConfigs?: IncomeConfig;

  /**
   * Game settings
   *
   * @generated from field: lilbattle.v1.GameSettings settings = 4;
   */
  settings?: GameSettings;
};

/**
 * Describes the message lilbattle.v1.GameConfiguration.
 * Use `create(GameConfigurationSchema)` to create a new message.
 */
export const GameConfigurationSchema: GenMessage<GameConfiguration> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 17);

/**
 * @generated from message lilbattle.v1.IncomeConfig
 */
export type IncomeConfig = Message<"lilbattle.v1.IncomeConfig"> & {
  /**
   * How much starting coins to give each player at the start of the agme
   *
   * @generated from field: int32 starting_coins = 1;
   */
  startingCoins: number;

  /**
   * Income each player just for being in the game each turn
   *
   * @generated from field: int32 game_income = 2;
   */
  gameIncome: number;

  /**
   * Income from each landbase per turn
   *
   * @generated from field: int32 landbase_income = 3;
   */
  landbaseIncome: number;

  /**
   * Income from each navalbase per turn
   *
   * @generated from field: int32 navalbase_income = 4;
   */
  navalbaseIncome: number;

  /**
   * Income from each airport base per turn
   *
   * @generated from field: int32 airportbase_income = 5;
   */
  airportbaseIncome: number;

  /**
   * Income from each missile silo per turn
   *
   * @generated from field: int32 missilesilo_income = 6;
   */
  missilesiloIncome: number;

  /**
   * Income from each mine per turn
   *
   * @generated from field: int32 mines_income = 7;
   */
  minesIncome: number;
};

/**
 * Describes the message lilbattle.v1.IncomeConfig.
 * Use `create(IncomeConfigSchema)` to create a new message.
 */
export const IncomeConfigSchema: GenMessage<IncomeConfig> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 18);

/**
 * @generated from message lilbattle.v1.GamePlayer
 */
export type GamePlayer = Message<"lilbattle.v1.GamePlayer"> & {
  /**
   * Player ID (1-based)
   *
   * @generated from field: int32 player_id = 1;
   */
  playerId: number;

  /**
   * ID of the system user that is assigned to this game player.  This is the "auth" user
   *
   * @generated from field: string user_id = 2;
   */
  userId: string;

  /**
   * Player type
   *
   * "human", "ai", "open"
   *
   * @generated from field: string player_type = 3;
   */
  playerType: string;

  /**
   * Player color
   *
   * @generated from field: string color = 4;
   */
  color: string;

  /**
   * Team ID (0 = no team, 1+ = team number)
   *
   * @generated from field: int32 team_id = 5;
   */
  teamId: number;

  /**
   * Nickname for the player in this game
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * Whether play is still in the game - can this just be inferred?
   *
   * @generated from field: bool is_active = 7;
   */
  isActive: boolean;

  /**
   * How many coins the player started off with
   *
   * @generated from field: int32 starting_coins = 8;
   */
  startingCoins: number;
};

/**
 * Describes the message lilbattle.v1.GamePlayer.
 * Use `create(GamePlayerSchema)` to create a new message.
 */
export const GamePlayerSchema: GenMessage<GamePlayer> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 19);

/**
 * @generated from message lilbattle.v1.GameTeam
 */
export type GameTeam = Message<"lilbattle.v1.GameTeam"> & {
  /**
   * ID of the team within the game (unique to the game)
   *
   * @generated from field: int32 team_id = 1;
   */
  teamId: number;

  /**
   * Name of the team - in a game
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Just a color for this team
   *
   * @generated from field: string color = 3;
   */
  color: string;

  /**
   * Whether team has active players - can also be inferred
   *
   * @generated from field: bool is_active = 4;
   */
  isActive: boolean;
};

/**
 * Describes the message lilbattle.v1.GameTeam.
 * Use `create(GameTeamSchema)` to create a new message.
 */
export const GameTeamSchema: GenMessage<GameTeam> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 20);

/**
 * @generated from message lilbattle.v1.GameSettings
 */
export type GameSettings = Message<"lilbattle.v1.GameSettings"> & {
  /**
   * List of allowed unit type IDs
   *
   * @generated from field: repeated int32 allowed_units = 1;
   */
  allowedUnits: number[];

  /**
   * Turn time limit in seconds (0 = no limit)
   *
   * @generated from field: int32 turn_time_limit = 2;
   */
  turnTimeLimit: number;

  /**
   * Team mode
   *
   * "ffa" or "teams"
   *
   * @generated from field: string team_mode = 3;
   */
  teamMode: string;

  /**
   * Maximum number of turns (0 = unlimited)
   *
   * @generated from field: int32 max_turns = 4;
   */
  maxTurns: number;
};

/**
 * Describes the message lilbattle.v1.GameSettings.
 * Use `create(GameSettingsSchema)` to create a new message.
 */
export const GameSettingsSchema: GenMessage<GameSettings> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 21);

/**
 * Runtime state for a player during the game
 * This is separate from GamePlayer (which is player configuration)
 * PlayerState is indexed by player_id in the player_states map
 *
 * @generated from message lilbattle.v1.PlayerState
 */
export type PlayerState = Message<"lilbattle.v1.PlayerState"> & {
  /**
   * Current coin balance (changes during gameplay via building, income, etc.)
   *
   * @generated from field: int32 coins = 1;
   */
  coins: number;

  /**
   * Whether player is still active in the game (not eliminated)
   *
   * @generated from field: bool is_active = 2;
   */
  isActive: boolean;
};

/**
 * Describes the message lilbattle.v1.PlayerState.
 * Use `create(PlayerStateSchema)` to create a new message.
 */
export const PlayerStateSchema: GenMessage<PlayerState> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 22);

/**
 * Holds the game's Active/Current state (eg world state)
 *
 * @generated from message lilbattle.v1.GameState
 */
export type GameState = Message<"lilbattle.v1.GameState"> & {
  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * ID of the game whos state is being tracked
   *
   * @generated from field: string game_id = 3;
   */
  gameId: string;

  /**
   * @generated from field: int32 turn_counter = 4;
   */
  turnCounter: number;

  /**
   * @generated from field: int32 current_player = 5;
   */
  currentPlayer: number;

  /**
   * Current world state
   *
   * @generated from field: lilbattle.v1.WorldData world_data = 6;
   */
  worldData?: WorldData;

  /**
   * Current state hash for validation
   *
   * @generated from field: string state_hash = 8;
   */
  stateHash: string;

  /**
   * Version number for optimistic locking
   *
   * @generated from field: int64 version = 9;
   */
  version: bigint;

  /**
   * @generated from field: lilbattle.v1.GameStatus status = 10;
   */
  status: GameStatus;

  /**
   * Only set after a win has been possible
   *
   * @generated from field: bool finished = 11;
   */
  finished: boolean;

  /**
   * @generated from field: int32 winning_player = 12;
   */
  winningPlayer: number;

  /**
   * @generated from field: int32 winning_team = 13;
   */
  winningTeam: number;

  /**
   * @generated from field: int64 current_group_number = 14;
   */
  currentGroupNumber: bigint;

  /**
   * Per-player runtime state, keyed by player_id (1-based)
   * This holds mutable player state like coins that changes during gameplay
   *
   * @generated from field: map<int32, lilbattle.v1.PlayerState> player_states = 15;
   */
  playerStates: { [key: number]: PlayerState };
};

/**
 * Describes the message lilbattle.v1.GameState.
 * Use `create(GameStateSchema)` to create a new message.
 */
export const GameStateSchema: GenMessage<GameState> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 23);

/**
 * Holds the game's move history (can be used as a replay log)
 *
 * @generated from message lilbattle.v1.GameMoveHistory
 */
export type GameMoveHistory = Message<"lilbattle.v1.GameMoveHistory"> & {
  /**
   * Move history for the game
   *
   * @generated from field: string game_id = 1;
   */
  gameId: string;

  /**
   * Each entry in our history is a "group" of moves
   *
   * @generated from field: repeated lilbattle.v1.GameMoveGroup groups = 2;
   */
  groups: GameMoveGroup[];
};

/**
 * Describes the message lilbattle.v1.GameMoveHistory.
 * Use `create(GameMoveHistorySchema)` to create a new message.
 */
export const GameMoveHistorySchema: GenMessage<GameMoveHistory> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 24);

/**
 * A move group - we can allow X moves in one "tick"
 *
 * @generated from message lilbattle.v1.GameMoveGroup
 */
export type GameMoveGroup = Message<"lilbattle.v1.GameMoveGroup"> & {
  /**
   * When the moves happened (or were submitted)
   *
   * @generated from field: google.protobuf.Timestamp started_at = 2;
   */
  startedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp ended_at = 3;
   */
  endedAt?: Timestamp;

  /**
   * Group number within the game - will be monotonically increasing
   *
   * @generated from field: int64 group_number = 4;
   */
  groupNumber: bigint;

  /**
   * *
   * List of moves to add - 
   *
   * @generated from field: repeated lilbattle.v1.GameMove moves = 5;
   */
  moves: GameMove[];
};

/**
 * Describes the message lilbattle.v1.GameMoveGroup.
 * Use `create(GameMoveGroupSchema)` to create a new message.
 */
export const GameMoveGroupSchema: GenMessage<GameMoveGroup> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 25);

/**
 * *
 * Represents a single move which can be one of many actions in the game
 *
 * @generated from message lilbattle.v1.GameMove
 */
export type GameMove = Message<"lilbattle.v1.GameMove"> & {
  /**
   * The player making the move
   *
   * @generated from field: int32 player = 1;
   */
  player: number;

  /**
   * Generated by the server
   *
   * @generated from field: int64 group_number = 2;
   */
  groupNumber: bigint;

  /**
   * Generated by the server - will be monotonically increasing within the group
   *
   * @generated from field: int64 move_number = 3;
   */
  moveNumber: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  /**
   * @generated from oneof lilbattle.v1.GameMove.move_type
   */
  moveType: {
    /**
     * @generated from field: lilbattle.v1.MoveUnitAction move_unit = 5;
     */
    value: MoveUnitAction;
    case: "moveUnit";
  } | {
    /**
     * @generated from field: lilbattle.v1.AttackUnitAction attack_unit = 6;
     */
    value: AttackUnitAction;
    case: "attackUnit";
  } | {
    /**
     * @generated from field: lilbattle.v1.EndTurnAction end_turn = 7;
     */
    value: EndTurnAction;
    case: "endTurn";
  } | {
    /**
     * @generated from field: lilbattle.v1.BuildUnitAction build_unit = 8;
     */
    value: BuildUnitAction;
    case: "buildUnit";
  } | {
    /**
     * @generated from field: lilbattle.v1.CaptureBuildingAction capture_building = 13;
     */
    value: CaptureBuildingAction;
    case: "captureBuilding";
  } | {
    /**
     * @generated from field: lilbattle.v1.HealUnitAction heal_unit = 14;
     */
    value: HealUnitAction;
    case: "healUnit";
  } | {
    /**
     * @generated from field: lilbattle.v1.FixUnitAction fix_unit = 15;
     */
    value: FixUnitAction;
    case: "fixUnit";
  } | { case: undefined; value?: undefined };

  /**
   * A monotonically increasing and unique (within the game) sequence number for the move
   * This is generated by the server
   *
   * @generated from field: int64 sequence_num = 9;
   */
  sequenceNum: bigint;

  /**
   * Whether the result is permenant and can be undone.
   * Just moving a unit for example is not permanent, but attacking a unit
   * would be (ie a player cannot undo it).  This is also determined by the server/validator
   *
   * @generated from field: bool is_permanent = 10;
   */
  isPermanent: boolean;

  /**
   *
   * The corresponding "result" for the move.  This can be "proposed" or can be evaluated.
   * Keeping this colocated with the Move for consistency and simplicity
   *
   * @generated from field: repeated lilbattle.v1.WorldChange changes = 11;
   */
  changes: WorldChange[];

  /**
   * Human redable description for say recording "commands" if any
   *
   * @generated from field: string description = 12;
   */
  description: string;
};

/**
 * Describes the message lilbattle.v1.GameMove.
 * Use `create(GameMoveSchema)` to create a new message.
 */
export const GameMoveSchema: GenMessage<GameMove> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 26);

/**
 * A unified "Position" type that can be used to 
 * specify locations via "string shortcuts" like A1, "3,2", "r2,4" (for row/col)
 * or even "relative" positions like "L,TL,TR,R"  in the shortcut field.
 * Or string q/r coordinates in the q and r fields.  This can also be used 
 * in the "response" to resolve a shortcut -> q,r
 *
 * @generated from message lilbattle.v1.Position
 */
export type Position = Message<"lilbattle.v1.Position"> & {
  /**
   * @generated from field: string label = 1;
   */
  label: string;

  /**
   * @generated from field: int32 q = 2;
   */
  q: number;

  /**
   * @generated from field: int32 r = 3;
   */
  r: number;
};

/**
 * Describes the message lilbattle.v1.Position.
 * Use `create(PositionSchema)` to create a new message.
 */
export const PositionSchema: GenMessage<Position> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 27);

/**
 * *
 * Move unit from one position to another
 *
 * @generated from message lilbattle.v1.MoveUnitAction
 */
export type MoveUnitAction = Message<"lilbattle.v1.MoveUnitAction"> & {
  /**
   * @generated from field: lilbattle.v1.Position from = 1;
   */
  from?: Position;

  /**
   * @generated from field: lilbattle.v1.Position to = 2;
   */
  to?: Position;

  /**
   * Optional fields that can be used for showing move options as well as debugging
   *
   * @generated from field: double movement_cost = 3;
   */
  movementCost: number;

  /**
   * Debug fields
   *
   * @generated from field: lilbattle.v1.Path reconstructed_path = 4;
   */
  reconstructedPath?: Path;
};

/**
 * Describes the message lilbattle.v1.MoveUnitAction.
 * Use `create(MoveUnitActionSchema)` to create a new message.
 */
export const MoveUnitActionSchema: GenMessage<MoveUnitAction> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 28);

/**
 * *
 * Attack with one unit against another
 *
 * @generated from message lilbattle.v1.AttackUnitAction
 */
export type AttackUnitAction = Message<"lilbattle.v1.AttackUnitAction"> & {
  /**
   * @generated from field: lilbattle.v1.Position attacker = 1;
   */
  attacker?: Position;

  /**
   * @generated from field: lilbattle.v1.Position defender = 2;
   */
  defender?: Position;

  /**
   * Optional fields for presenting during "options" and debugging
   *
   * @generated from field: int32 target_unit_type = 7;
   */
  targetUnitType: number;

  /**
   * @generated from field: int32 target_unit_health = 8;
   */
  targetUnitHealth: number;

  /**
   * @generated from field: bool can_attack = 9;
   */
  canAttack: boolean;

  /**
   * Estimated damage this attack would deal
   *
   * @generated from field: int32 damage_estimate = 10;
   */
  damageEstimate: number;
};

/**
 * Describes the message lilbattle.v1.AttackUnitAction.
 * Use `create(AttackUnitActionSchema)` to create a new message.
 */
export const AttackUnitActionSchema: GenMessage<AttackUnitAction> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 29);

/**
 * *
 * An action to build a unit (at a city tile)
 *
 * @generated from message lilbattle.v1.BuildUnitAction
 */
export type BuildUnitAction = Message<"lilbattle.v1.BuildUnitAction"> & {
  /**
   * @generated from field: lilbattle.v1.Position pos = 1;
   */
  pos?: Position;

  /**
   * @generated from field: int32 unit_type = 2;
   */
  unitType: number;

  /**
   * @generated from field: int32 cost = 3;
   */
  cost: number;
};

/**
 * Describes the message lilbattle.v1.BuildUnitAction.
 * Use `create(BuildUnitActionSchema)` to create a new message.
 */
export const BuildUnitActionSchema: GenMessage<BuildUnitAction> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 30);

/**
 * *
 * A move where a unit can capture a building
 *
 * @generated from message lilbattle.v1.CaptureBuildingAction
 */
export type CaptureBuildingAction = Message<"lilbattle.v1.CaptureBuildingAction"> & {
  /**
   * @generated from field: lilbattle.v1.Position pos = 1;
   */
  pos?: Position;

  /**
   * @generated from field: int32 tile_type = 3;
   */
  tileType: number;
};

/**
 * Describes the message lilbattle.v1.CaptureBuildingAction.
 * Use `create(CaptureBuildingActionSchema)` to create a new message.
 */
export const CaptureBuildingActionSchema: GenMessage<CaptureBuildingAction> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 31);

/**
 * *
 * End current player's turn
 *
 * No additional fields needed
 *
 * @generated from message lilbattle.v1.EndTurnAction
 */
export type EndTurnAction = Message<"lilbattle.v1.EndTurnAction"> & {
};

/**
 * Describes the message lilbattle.v1.EndTurnAction.
 * Use `create(EndTurnActionSchema)` to create a new message.
 */
export const EndTurnActionSchema: GenMessage<EndTurnAction> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 32);

/**
 * *
 * Heal a unit - player manually chooses to heal instead of attacking/moving
 * Auto-healing at turn start is handled separately in TopUpUnitIfNeeded
 *
 * @generated from message lilbattle.v1.HealUnitAction
 */
export type HealUnitAction = Message<"lilbattle.v1.HealUnitAction"> & {
  /**
   * Position of unit to heal
   *
   * @generated from field: lilbattle.v1.Position pos = 1;
   */
  pos?: Position;

  /**
   * Amount of health to restore
   *
   * @generated from field: int32 heal_amount = 2;
   */
  healAmount: number;
};

/**
 * Describes the message lilbattle.v1.HealUnitAction.
 * Use `create(HealUnitActionSchema)` to create a new message.
 */
export const HealUnitActionSchema: GenMessage<HealUnitAction> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 33);

/**
 * *
 * Fix (repair) another friendly unit - used by Medic, Engineer, Stratotanker, Tugboat, Aircraft Carrier
 * The fixer must be adjacent to the target unit
 *
 * @generated from message lilbattle.v1.FixUnitAction
 */
export type FixUnitAction = Message<"lilbattle.v1.FixUnitAction"> & {
  /**
   * Position of the unit doing the fixing
   *
   * @generated from field: lilbattle.v1.Position fixer = 1;
   */
  fixer?: Position;

  /**
   * Position of the friendly unit being fixed
   *
   * @generated from field: lilbattle.v1.Position target = 2;
   */
  target?: Position;

  /**
   * Amount of health to restore (optional, server calculates if not provided)
   *
   * @generated from field: int32 fix_amount = 3;
   */
  fixAmount: number;
};

/**
 * Describes the message lilbattle.v1.FixUnitAction.
 * Use `create(FixUnitActionSchema)` to create a new message.
 */
export const FixUnitActionSchema: GenMessage<FixUnitAction> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 34);

/**
 * *
 * Represents a change to the game world
 *
 * @generated from message lilbattle.v1.WorldChange
 */
export type WorldChange = Message<"lilbattle.v1.WorldChange"> & {
  /**
   * When did this change happen
   *
   * @generated from oneof lilbattle.v1.WorldChange.change_type
   */
  changeType: {
    /**
     * @generated from field: lilbattle.v1.UnitMovedChange unit_moved = 1;
     */
    value: UnitMovedChange;
    case: "unitMoved";
  } | {
    /**
     * @generated from field: lilbattle.v1.UnitDamagedChange unit_damaged = 2;
     */
    value: UnitDamagedChange;
    case: "unitDamaged";
  } | {
    /**
     * @generated from field: lilbattle.v1.UnitKilledChange unit_killed = 3;
     */
    value: UnitKilledChange;
    case: "unitKilled";
  } | {
    /**
     * @generated from field: lilbattle.v1.PlayerChangedChange player_changed = 4;
     */
    value: PlayerChangedChange;
    case: "playerChanged";
  } | {
    /**
     * @generated from field: lilbattle.v1.UnitBuiltChange unit_built = 5;
     */
    value: UnitBuiltChange;
    case: "unitBuilt";
  } | {
    /**
     * @generated from field: lilbattle.v1.CoinsChangedChange coins_changed = 6;
     */
    value: CoinsChangedChange;
    case: "coinsChanged";
  } | {
    /**
     * @generated from field: lilbattle.v1.TileCapturedChange tile_captured = 7;
     */
    value: TileCapturedChange;
    case: "tileCaptured";
  } | {
    /**
     * @generated from field: lilbattle.v1.CaptureStartedChange capture_started = 8;
     */
    value: CaptureStartedChange;
    case: "captureStarted";
  } | {
    /**
     * @generated from field: lilbattle.v1.UnitHealedChange unit_healed = 9;
     */
    value: UnitHealedChange;
    case: "unitHealed";
  } | {
    /**
     * @generated from field: lilbattle.v1.UnitFixedChange unit_fixed = 10;
     */
    value: UnitFixedChange;
    case: "unitFixed";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message lilbattle.v1.WorldChange.
 * Use `create(WorldChangeSchema)` to create a new message.
 */
export const WorldChangeSchema: GenMessage<WorldChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 35);

/**
 * *
 * A unit was healed
 *
 * @generated from message lilbattle.v1.UnitHealedChange
 */
export type UnitHealedChange = Message<"lilbattle.v1.UnitHealedChange"> & {
  /**
   * Unit state before healing
   *
   * @generated from field: lilbattle.v1.Unit previous_unit = 1;
   */
  previousUnit?: Unit;

  /**
   * Unit state after healing
   *
   * @generated from field: lilbattle.v1.Unit updated_unit = 2;
   */
  updatedUnit?: Unit;

  /**
   * Amount healed
   *
   * @generated from field: int32 heal_amount = 3;
   */
  healAmount: number;
};

/**
 * Describes the message lilbattle.v1.UnitHealedChange.
 * Use `create(UnitHealedChangeSchema)` to create a new message.
 */
export const UnitHealedChangeSchema: GenMessage<UnitHealedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 36);

/**
 * *
 * A unit was fixed (repaired) by another unit
 *
 * @generated from message lilbattle.v1.UnitFixedChange
 */
export type UnitFixedChange = Message<"lilbattle.v1.UnitFixedChange"> & {
  /**
   * Unit that performed the fix
   *
   * @generated from field: lilbattle.v1.Unit fixer_unit = 1;
   */
  fixerUnit?: Unit;

  /**
   * Target unit state before fix
   *
   * @generated from field: lilbattle.v1.Unit previous_target = 2;
   */
  previousTarget?: Unit;

  /**
   * Target unit state after fix
   *
   * @generated from field: lilbattle.v1.Unit updated_target = 3;
   */
  updatedTarget?: Unit;

  /**
   * Amount of health restored
   *
   * @generated from field: int32 fix_amount = 4;
   */
  fixAmount: number;
};

/**
 * Describes the message lilbattle.v1.UnitFixedChange.
 * Use `create(UnitFixedChangeSchema)` to create a new message.
 */
export const UnitFixedChangeSchema: GenMessage<UnitFixedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 37);

/**
 * *
 * A unit moved from one position to another
 *
 * @generated from message lilbattle.v1.UnitMovedChange
 */
export type UnitMovedChange = Message<"lilbattle.v1.UnitMovedChange"> & {
  /**
   * Complete unit state before the move
   *
   * @generated from field: lilbattle.v1.Unit previous_unit = 6;
   */
  previousUnit?: Unit;

  /**
   * Complete unit state after the move (includes updated position, distanceLeft, etc.)
   *
   * @generated from field: lilbattle.v1.Unit updated_unit = 7;
   */
  updatedUnit?: Unit;
};

/**
 * Describes the message lilbattle.v1.UnitMovedChange.
 * Use `create(UnitMovedChangeSchema)` to create a new message.
 */
export const UnitMovedChangeSchema: GenMessage<UnitMovedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 38);

/**
 * *
 * A unit took damage
 *
 * @generated from message lilbattle.v1.UnitDamagedChange
 */
export type UnitDamagedChange = Message<"lilbattle.v1.UnitDamagedChange"> & {
  /**
   * Complete unit state before taking damage
   *
   * @generated from field: lilbattle.v1.Unit previous_unit = 6;
   */
  previousUnit?: Unit;

  /**
   * Complete unit state after taking damage
   *
   * @generated from field: lilbattle.v1.Unit updated_unit = 7;
   */
  updatedUnit?: Unit;
};

/**
 * Describes the message lilbattle.v1.UnitDamagedChange.
 * Use `create(UnitDamagedChangeSchema)` to create a new message.
 */
export const UnitDamagedChangeSchema: GenMessage<UnitDamagedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 39);

/**
 * *
 * A unit was killed
 *
 * @generated from message lilbattle.v1.UnitKilledChange
 */
export type UnitKilledChange = Message<"lilbattle.v1.UnitKilledChange"> & {
  /**
   * Complete unit state before being killed
   *
   * @generated from field: lilbattle.v1.Unit previous_unit = 6;
   */
  previousUnit?: Unit;
};

/**
 * Describes the message lilbattle.v1.UnitKilledChange.
 * Use `create(UnitKilledChangeSchema)` to create a new message.
 */
export const UnitKilledChangeSchema: GenMessage<UnitKilledChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 40);

/**
 * *
 * Active player changed
 *
 * @generated from message lilbattle.v1.PlayerChangedChange
 */
export type PlayerChangedChange = Message<"lilbattle.v1.PlayerChangedChange"> & {
  /**
   * @generated from field: int32 previous_player = 1;
   */
  previousPlayer: number;

  /**
   * @generated from field: int32 new_player = 2;
   */
  newPlayer: number;

  /**
   * @generated from field: int32 previous_turn = 3;
   */
  previousTurn: number;

  /**
   * @generated from field: int32 new_turn = 4;
   */
  newTurn: number;

  /**
   * Units that had their movement/health reset for the new turn
   *
   * @generated from field: repeated lilbattle.v1.Unit reset_units = 5;
   */
  resetUnits: Unit[];
};

/**
 * Describes the message lilbattle.v1.PlayerChangedChange.
 * Use `create(PlayerChangedChangeSchema)` to create a new message.
 */
export const PlayerChangedChangeSchema: GenMessage<PlayerChangedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 41);

/**
 * *
 * A new unit was built at a tile
 *
 * @generated from message lilbattle.v1.UnitBuiltChange
 */
export type UnitBuiltChange = Message<"lilbattle.v1.UnitBuiltChange"> & {
  /**
   * The newly created unit
   *
   * @generated from field: lilbattle.v1.Unit unit = 1;
   */
  unit?: Unit;

  /**
   * Tile coordinates where unit was built
   *
   * @generated from field: int32 tile_q = 2;
   */
  tileQ: number;

  /**
   * @generated from field: int32 tile_r = 3;
   */
  tileR: number;

  /**
   * Cost in coins
   *
   * @generated from field: int32 coins_cost = 4;
   */
  coinsCost: number;

  /**
   * Player's remaining coins after build
   *
   * @generated from field: int32 player_coins = 5;
   */
  playerCoins: number;
};

/**
 * Describes the message lilbattle.v1.UnitBuiltChange.
 * Use `create(UnitBuiltChangeSchema)` to create a new message.
 */
export const UnitBuiltChangeSchema: GenMessage<UnitBuiltChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 42);

/**
 * *
 * A player's coin balance changed
 *
 * @generated from message lilbattle.v1.CoinsChangedChange
 */
export type CoinsChangedChange = Message<"lilbattle.v1.CoinsChangedChange"> & {
  /**
   * Which player's coins changed
   *
   * @generated from field: int32 player_id = 1;
   */
  playerId: number;

  /**
   * Previous coin balance
   *
   * @generated from field: int32 previous_coins = 2;
   */
  previousCoins: number;

  /**
   * New coin balance
   *
   * @generated from field: int32 new_coins = 3;
   */
  newCoins: number;

  /**
   * Reason for change: "build", "income", "repair", etc.
   *
   * @generated from field: string reason = 4;
   */
  reason: string;
};

/**
 * Describes the message lilbattle.v1.CoinsChangedChange.
 * Use `create(CoinsChangedChangeSchema)` to create a new message.
 */
export const CoinsChangedChangeSchema: GenMessage<CoinsChangedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 43);

/**
 * *
 * A tile was captured by a unit
 *
 * @generated from message lilbattle.v1.TileCapturedChange
 */
export type TileCapturedChange = Message<"lilbattle.v1.TileCapturedChange"> & {
  /**
   * The unit that captured the tile
   *
   * @generated from field: lilbattle.v1.Unit capturing_unit = 1;
   */
  capturingUnit?: Unit;

  /**
   * Tile coordinates
   *
   * @generated from field: int32 tile_q = 2;
   */
  tileQ: number;

  /**
   * @generated from field: int32 tile_r = 3;
   */
  tileR: number;

  /**
   * Tile type
   *
   * @generated from field: int32 tile_type = 4;
   */
  tileType: number;

  /**
   * Previous owner (0 for neutral)
   *
   * @generated from field: int32 previous_owner = 5;
   */
  previousOwner: number;

  /**
   * New owner
   *
   * @generated from field: int32 new_owner = 6;
   */
  newOwner: number;
};

/**
 * Describes the message lilbattle.v1.TileCapturedChange.
 * Use `create(TileCapturedChangeSchema)` to create a new message.
 */
export const TileCapturedChangeSchema: GenMessage<TileCapturedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 44);

/**
 * *
 * A unit started capturing a building (capture not yet complete)
 *
 * @generated from message lilbattle.v1.CaptureStartedChange
 */
export type CaptureStartedChange = Message<"lilbattle.v1.CaptureStartedChange"> & {
  /**
   * The unit starting the capture
   *
   * @generated from field: lilbattle.v1.Unit capturing_unit = 1;
   */
  capturingUnit?: Unit;

  /**
   * Tile coordinates
   *
   * @generated from field: int32 tile_q = 2;
   */
  tileQ: number;

  /**
   * @generated from field: int32 tile_r = 3;
   */
  tileR: number;

  /**
   * Tile type
   *
   * @generated from field: int32 tile_type = 4;
   */
  tileType: number;

  /**
   * Current owner (0 for neutral)
   *
   * @generated from field: int32 current_owner = 5;
   */
  currentOwner: number;
};

/**
 * Describes the message lilbattle.v1.CaptureStartedChange.
 * Use `create(CaptureStartedChangeSchema)` to create a new message.
 */
export const CaptureStartedChangeSchema: GenMessage<CaptureStartedChange> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 45);

/**
 * Compact representation of all reachable paths from a source
 *
 * @generated from message lilbattle.v1.AllPaths
 */
export type AllPaths = Message<"lilbattle.v1.AllPaths"> & {
  /**
   * Starting coordinate for all paths
   *
   * @generated from field: int32 source_q = 1;
   */
  sourceQ: number;

  /**
   * @generated from field: int32 source_r = 2;
   */
  sourceR: number;

  /**
   * Map of edges: key is "toQ,toR" for quick parent lookup
   * Each edge represents the optimal way to reach 'to' from its parent
   *
   * @generated from field: map<string, lilbattle.v1.PathEdge> edges = 3;
   */
  edges: { [key: string]: PathEdge };
};

/**
 * Describes the message lilbattle.v1.AllPaths.
 * Use `create(AllPathsSchema)` to create a new message.
 */
export const AllPathsSchema: GenMessage<AllPaths> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 46);

/**
 * A single edge in a path with movement details
 *
 * @generated from message lilbattle.v1.PathEdge
 */
export type PathEdge = Message<"lilbattle.v1.PathEdge"> & {
  /**
   * Parent coordinate Q
   *
   * @generated from field: int32 from_q = 1;
   */
  fromQ: number;

  /**
   * Parent coordinate R
   *
   * @generated from field: int32 from_r = 2;
   */
  fromR: number;

  /**
   * Destination coordinate Q
   *
   * @generated from field: int32 to_q = 3;
   */
  toQ: number;

  /**
   * Destination coordinate R
   *
   * @generated from field: int32 to_r = 4;
   */
  toR: number;

  /**
   * Cost to move from 'from' to 'to' (edge cost)
   *
   * @generated from field: double movement_cost = 5;
   */
  movementCost: number;

  /**
   * Total cumulative cost from source to 'to'
   *
   * @generated from field: double total_cost = 6;
   */
  totalCost: number;

  /**
   * e.g., "mountain", "plains", "forest"
   *
   * @generated from field: string terrain_type = 7;
   */
  terrainType: string;

  /**
   * e.g., "Mountain costs Soldier 4 movement points"
   *
   * @generated from field: string explanation = 8;
   */
  explanation: string;

  /**
   * True if destination tile has a friendly unit (pass-through only, cannot land)
   *
   * @generated from field: bool is_occupied = 9;
   */
  isOccupied: boolean;
};

/**
 * Describes the message lilbattle.v1.PathEdge.
 * Use `create(PathEdgeSchema)` to create a new message.
 */
export const PathEdgeSchema: GenMessage<PathEdge> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 47);

/**
 * Full path from source to destination (constructed on-demand from AllPaths)
 *
 * @generated from message lilbattle.v1.Path
 */
export type Path = Message<"lilbattle.v1.Path"> & {
  /**
   * Edges in order from source to destination
   *
   * @generated from field: repeated lilbattle.v1.PathEdge edges = 1;
   */
  edges: PathEdge[];

  /**
   * len(directions) = len(edges) - 1
   * and directions[i] = direction from edge[i - 1] -> edge[i]
   *
   * @generated from field: repeated lilbattle.v1.PathDirection directions = 2;
   */
  directions: PathDirection[];

  /**
   * Sum of all edge costs
   *
   * @generated from field: double total_cost = 3;
   */
  totalCost: number;
};

/**
 * Describes the message lilbattle.v1.Path.
 * Use `create(PathSchema)` to create a new message.
 */
export const PathSchema: GenMessage<Path> = /*@__PURE__*/
  messageDesc(file_lilbattle_v1_models_models, 48);

/**
 * Crossing types for terrain improvements (roads on land, bridges on water)
 *
 * @generated from enum lilbattle.v1.CrossingType
 */
export enum CrossingType {
  /**
   * @generated from enum value: CROSSING_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Road on land terrain
   *
   * @generated from enum value: CROSSING_TYPE_ROAD = 1;
   */
  ROAD = 1,

  /**
   * Bridge over water terrain
   *
   * @generated from enum value: CROSSING_TYPE_BRIDGE = 2;
   */
  BRIDGE = 2,
}

/**
 * Describes the enum lilbattle.v1.CrossingType.
 */
export const CrossingTypeSchema: GenEnum<CrossingType> = /*@__PURE__*/
  enumDesc(file_lilbattle_v1_models_models, 0);

/**
 * Terrain type classification - used for gameplay logic
 *
 * @generated from enum lilbattle.v1.TerrainType
 */
export enum TerrainType {
  /**
   * @generated from enum value: TERRAIN_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Player-owned structures (bases, hospitals, etc.)
   *
   * @generated from enum value: TERRAIN_TYPE_CITY = 1;
   */
  CITY = 1,

  /**
   * Neutral natural terrain (grass, mountains, etc.)
   *
   * @generated from enum value: TERRAIN_TYPE_NATURE = 2;
   */
  NATURE = 2,

  /**
   * Bridge crossings
   *
   * @generated from enum value: TERRAIN_TYPE_BRIDGE = 3;
   */
  BRIDGE = 3,

  /**
   * Water tiles
   *
   * @generated from enum value: TERRAIN_TYPE_WATER = 4;
   */
  WATER = 4,

  /**
   * Road tiles
   *
   * @generated from enum value: TERRAIN_TYPE_ROAD = 5;
   */
  ROAD = 5,
}

/**
 * Describes the enum lilbattle.v1.TerrainType.
 */
export const TerrainTypeSchema: GenEnum<TerrainType> = /*@__PURE__*/
  enumDesc(file_lilbattle_v1_models_models, 1);

/**
 * /////// Game related models
 *
 *
 * @generated from enum lilbattle.v1.GameStatus
 */
export enum GameStatus {
  /**
   * @generated from enum value: GAME_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: GAME_STATUS_PLAYING = 1;
   */
  PLAYING = 1,

  /**
   * @generated from enum value: GAME_STATUS_PAUSED = 2;
   */
  PAUSED = 2,

  /**
   * @generated from enum value: GAME_STATUS_ENDED = 3;
   */
  ENDED = 3,
}

/**
 * Describes the enum lilbattle.v1.GameStatus.
 */
export const GameStatusSchema: GenEnum<GameStatus> = /*@__PURE__*/
  enumDesc(file_lilbattle_v1_models_models, 2);

/**
 * @generated from enum lilbattle.v1.PathDirection
 */
export enum PathDirection {
  /**
   * @generated from enum value: PATH_DIRECTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PATH_DIRECTION_LEFT = 1;
   */
  LEFT = 1,

  /**
   * @generated from enum value: PATH_DIRECTION_TOP_LEFT = 2;
   */
  TOP_LEFT = 2,

  /**
   * @generated from enum value: PATH_DIRECTION_TOP_RIGHT = 3;
   */
  TOP_RIGHT = 3,

  /**
   * @generated from enum value: PATH_DIRECTION_RIGHT = 4;
   */
  RIGHT = 4,

  /**
   * @generated from enum value: PATH_DIRECTION_BOTTOM_RIGHT = 5;
   */
  BOTTOM_RIGHT = 5,

  /**
   * @generated from enum value: PATH_DIRECTION_BOTTOM_LEFT = 6;
   */
  BOTTOM_LEFT = 6,
}

/**
 * Describes the enum lilbattle.v1.PathDirection.
 */
export const PathDirectionSchema: GenEnum<PathDirection> = /*@__PURE__*/
  enumDesc(file_lilbattle_v1_models_models, 3);

