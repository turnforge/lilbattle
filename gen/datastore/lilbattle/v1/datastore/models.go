// Code generated by protoc-gen-dal-datastore. DO NOT EDIT.
package datastore

import (
	"encoding/json"
	"fmt"
	"time"

	"cloud.google.com/go/datastore"
	models "github.com/turnforge/lilbattle/gen/go/lilbattle/v1/models"
)

// IndexInfoDatastore is the Datastore entity for the source message.
type IndexInfoDatastore struct {
	Key *datastore.Key `datastore:"-"`

	LastUpdatedAt time.Time `datastore:"last_updated_at"`

	LastIndexedAt time.Time `datastore:"last_indexed_at"`

	NeedsIndexing bool `datastore:"needs_indexing"`
}

// TileDatastore is the Datastore entity for the source message.
type TileDatastore struct {
	Key *datastore.Key `datastore:"-"`

	Q int32 `datastore:"q"`

	R int32 `datastore:"r"`

	TileType int32 `datastore:"tile_type"`

	Player int32 `datastore:"player"`

	Shortcut string `datastore:"shortcut"`

	LastActedTurn int32 `datastore:"last_acted_turn"`

	LastToppedupTurn int32 `datastore:"last_toppedup_turn"`
}

// CrossingDatastore is the Datastore entity for the source message.
type CrossingDatastore struct {
	Key *datastore.Key `datastore:"-"`

	Type models.CrossingType `datastore:"type"`

	ConnectsTo []bool `datastore:"connects_to"`
}

// UnitDatastore is the Datastore entity for the source message.
type UnitDatastore struct {
	Key *datastore.Key `datastore:"-"`

	Q int32 `datastore:"q"`

	R int32 `datastore:"r"`

	Player int32 `datastore:"player"`

	UnitType int32 `datastore:"unit_type"`

	Shortcut string `datastore:"shortcut"`

	AvailableHealth int32 `datastore:"available_health"`

	DistanceLeft float64 `datastore:"distance_left"`

	LastActedTurn int32 `datastore:"last_acted_turn"`

	LastToppedupTurn int32 `datastore:"last_toppedup_turn"`

	AttacksReceivedThisTurn int32 `datastore:"attacks_received_this_turn"`

	AttackHistory []AttackRecordDatastore `datastore:"attack_history,noindex"`

	ProgressionStep int32 `datastore:"progression_step"`

	ChosenAlternative string `datastore:"chosen_alternative"`

	CaptureStartedTurn int32 `datastore:"capture_started_turn"`
}

// AttackRecordDatastore is the Datastore entity for the source message.
type AttackRecordDatastore struct {
	Key *datastore.Key `datastore:"-"`

	Q int32 `datastore:"q"`

	R int32 `datastore:"r"`

	IsRanged bool `datastore:"is_ranged"`

	TurnNumber int32 `datastore:"turn_number"`
}

// WorldDatastore is the Datastore entity for the source message.
type WorldDatastore struct {
	Key *datastore.Key `datastore:"-"`

	CreatedAt time.Time `datastore:"created_at"`

	UpdatedAt time.Time `datastore:"updated_at"`

	Version int64 `datastore:"version"`

	Id string `datastore:"-"`

	CreatorId string `datastore:"creator_id"`

	Name string `datastore:"name"`

	Description string `datastore:"description"`

	Tags []string `datastore:"tags,noindex"`

	ImageUrl string `datastore:"image_url"`

	Difficulty string `datastore:"difficulty"`

	PreviewUrls []string `datastore:"preview_urls,noindex"`

	DefaultGameConfig GameConfigurationDatastore `datastore:"default_game_config,noindex"`

	SearchIndexInfo IndexInfoDatastore `datastore:"search_index_info,flatten"`
}

// Kind returns the Datastore kind name for WorldDatastore.
func (*WorldDatastore) Kind() string {
	return "World"
}

// WorldDataDatastore is the Datastore entity for the source message.
type WorldDataDatastore struct {
	Key *datastore.Key `datastore:"-"`

	TilesMap map[string]TileDatastore `datastore:"tiles_map,noindex"`

	WorldId string `datastore:"-"`

	UnitsMap map[string]UnitDatastore `datastore:"units_map,noindex"`

	ScreenshotIndexInfo IndexInfoDatastore `datastore:"screenshot_index_info,flatten"`

	ContentHash string `datastore:"content_hash"`

	Version int64 `datastore:"version"`

	Crossings map[string]CrossingDatastore `datastore:"crossings,noindex"`
}

// Kind returns the Datastore kind name for WorldDataDatastore.
func (*WorldDataDatastore) Kind() string {
	return "WorldData"
}

// Save implements the PropertyLoadSaver interface for WorldDataDatastore.
// It serializes map fields to JSON since Datastore doesn't natively support Go maps.
func (m *WorldDataDatastore) Save() ([]datastore.Property, error) {
	// First, get the default properties using datastore.SaveStruct
	// We need a copy without the map fields to avoid the "unsupported struct field type" error
	props, err := m.saveNonMapFields()
	if err != nil {
		return nil, err
	}

	// Serialize TilesMap map to JSON
	if m.TilesMap != nil {
		TilesMapJSON, err := json.Marshal(m.TilesMap)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal TilesMap: %w", err)
		}
		props = append(props, datastore.Property{
			Name:    "tiles_map",
			Value:   TilesMapJSON,
			NoIndex: true, // Maps are typically not indexed
		})
	}

	// Serialize UnitsMap map to JSON
	if m.UnitsMap != nil {
		UnitsMapJSON, err := json.Marshal(m.UnitsMap)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal UnitsMap: %w", err)
		}
		props = append(props, datastore.Property{
			Name:    "units_map",
			Value:   UnitsMapJSON,
			NoIndex: true, // Maps are typically not indexed
		})
	}

	// Serialize Crossings map to JSON
	if m.Crossings != nil {
		CrossingsJSON, err := json.Marshal(m.Crossings)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal Crossings: %w", err)
		}
		props = append(props, datastore.Property{
			Name:    "crossings",
			Value:   CrossingsJSON,
			NoIndex: true, // Maps are typically not indexed
		})
	}

	return props, nil
}

// saveNonMapFields saves all non-map fields using a temporary struct.
func (m *WorldDataDatastore) saveNonMapFields() ([]datastore.Property, error) {
	// Create a temporary struct with only the non-map fields
	type nonMapFields struct {
		Key *datastore.Key `datastore:"-"`

		WorldId string `datastore:"-"`

		ScreenshotIndexInfo IndexInfoDatastore `datastore:"screenshot_index_info,flatten"`

		ContentHash string `datastore:"content_hash"`

		Version int64 `datastore:"version"`
	}

	tmp := nonMapFields{

		Key: m.Key,

		WorldId: m.WorldId,

		ScreenshotIndexInfo: m.ScreenshotIndexInfo,

		ContentHash: m.ContentHash,

		Version: m.Version,
	}

	return datastore.SaveStruct(&tmp)
}

// Load implements the PropertyLoadSaver interface for WorldDataDatastore.
// It deserializes JSON-encoded map fields back to Go maps.
func (m *WorldDataDatastore) Load(props []datastore.Property) error {
	// Separate map properties from regular properties
	var regularProps []datastore.Property

	var TilesMapProp *datastore.Property

	var UnitsMapProp *datastore.Property

	var CrossingsProp *datastore.Property

	for i := range props {
		switch props[i].Name {

		case "tiles_map":
			TilesMapProp = &props[i]

		case "units_map":
			UnitsMapProp = &props[i]

		case "crossings":
			CrossingsProp = &props[i]

		default:
			regularProps = append(regularProps, props[i])
		}
	}

	// Load non-map fields using a temporary struct
	type nonMapFields struct {
		Key *datastore.Key `datastore:"-"`

		WorldId string `datastore:"-"`

		ScreenshotIndexInfo IndexInfoDatastore `datastore:"screenshot_index_info,flatten"`

		ContentHash string `datastore:"content_hash"`

		Version int64 `datastore:"version"`
	}

	var tmp nonMapFields
	if err := datastore.LoadStruct(&tmp, regularProps); err != nil {
		return err
	}

	// Copy non-map fields back

	m.Key = tmp.Key

	m.WorldId = tmp.WorldId

	m.ScreenshotIndexInfo = tmp.ScreenshotIndexInfo

	m.ContentHash = tmp.ContentHash

	m.Version = tmp.Version

	// Deserialize TilesMap from JSON
	if TilesMapProp != nil {
		var jsonBytes []byte
		switch v := TilesMapProp.Value.(type) {
		case []byte:
			jsonBytes = v
		case string:
			jsonBytes = []byte(v)
		default:
			return fmt.Errorf("unexpected type for tiles_map: %T", TilesMapProp.Value)
		}
		if len(jsonBytes) > 0 {
			m.TilesMap = make(map[string]TileDatastore)
			if err := json.Unmarshal(jsonBytes, &m.TilesMap); err != nil {
				return fmt.Errorf("failed to unmarshal TilesMap: %w", err)
			}
		}
	}

	// Deserialize UnitsMap from JSON
	if UnitsMapProp != nil {
		var jsonBytes []byte
		switch v := UnitsMapProp.Value.(type) {
		case []byte:
			jsonBytes = v
		case string:
			jsonBytes = []byte(v)
		default:
			return fmt.Errorf("unexpected type for units_map: %T", UnitsMapProp.Value)
		}
		if len(jsonBytes) > 0 {
			m.UnitsMap = make(map[string]UnitDatastore)
			if err := json.Unmarshal(jsonBytes, &m.UnitsMap); err != nil {
				return fmt.Errorf("failed to unmarshal UnitsMap: %w", err)
			}
		}
	}

	// Deserialize Crossings from JSON
	if CrossingsProp != nil {
		var jsonBytes []byte
		switch v := CrossingsProp.Value.(type) {
		case []byte:
			jsonBytes = v
		case string:
			jsonBytes = []byte(v)
		default:
			return fmt.Errorf("unexpected type for crossings: %T", CrossingsProp.Value)
		}
		if len(jsonBytes) > 0 {
			m.Crossings = make(map[string]CrossingDatastore)
			if err := json.Unmarshal(jsonBytes, &m.Crossings); err != nil {
				return fmt.Errorf("failed to unmarshal Crossings: %w", err)
			}
		}
	}

	return nil
}

// GameDatastore is the Datastore entity for the source message.
type GameDatastore struct {
	Key *datastore.Key `datastore:"-"`

	CreatedAt time.Time `datastore:"created_at"`

	UpdatedAt time.Time `datastore:"updated_at"`

	Version int64 `datastore:"version"`

	Id string `datastore:"-"`

	CreatorId string `datastore:"creator_id"`

	WorldId string `datastore:"world_id"`

	Name string `datastore:"name"`

	Description string `datastore:"description"`

	Tags []string `datastore:"tags,noindex"`

	ImageUrl string `datastore:"image_url"`

	Difficulty string `datastore:"difficulty"`

	Config GameConfigurationDatastore `datastore:"config,noindex"`

	PreviewUrls []string `datastore:"preview_urls,noindex"`

	SearchIndexInfo IndexInfoDatastore `datastore:"search_index_info,flatten"`
}

// Kind returns the Datastore kind name for GameDatastore.
func (*GameDatastore) Kind() string {
	return "Game"
}

// GameStateDatastore is the Datastore entity for the source message.
type GameStateDatastore struct {
	Key *datastore.Key `datastore:"-"`

	UpdatedAt time.Time `datastore:"updated_at"`

	GameId string `datastore:"-"`

	TurnCounter int32 `datastore:"turn_counter"`

	CurrentPlayer int32 `datastore:"current_player"`

	WorldData WorldDataDatastore `datastore:"world_data,noindex"`

	StateHash string `datastore:"state_hash"`

	Version int64 `datastore:"version"`

	Status models.GameStatus `datastore:"status"`

	Finished bool `datastore:"finished"`

	WinningPlayer int32 `datastore:"winning_player"`

	WinningTeam int32 `datastore:"winning_team"`

	CurrentGroupNumber int64 `datastore:"current_group_number"`

	PlayerStates map[int32]PlayerStateDatastore `datastore:"player_states,noindex"`
}

// Kind returns the Datastore kind name for GameStateDatastore.
func (*GameStateDatastore) Kind() string {
	return "GameState"
}

// Save implements the PropertyLoadSaver interface for GameStateDatastore.
// It serializes map fields to JSON since Datastore doesn't natively support Go maps.
func (m *GameStateDatastore) Save() ([]datastore.Property, error) {
	// First, get the default properties using datastore.SaveStruct
	// We need a copy without the map fields to avoid the "unsupported struct field type" error
	props, err := m.saveNonMapFields()
	if err != nil {
		return nil, err
	}

	// Serialize PlayerStates map to JSON
	if m.PlayerStates != nil {
		PlayerStatesJSON, err := json.Marshal(m.PlayerStates)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal PlayerStates: %w", err)
		}
		props = append(props, datastore.Property{
			Name:    "player_states",
			Value:   PlayerStatesJSON,
			NoIndex: true, // Maps are typically not indexed
		})
	}

	return props, nil
}

// saveNonMapFields saves all non-map fields using a temporary struct.
func (m *GameStateDatastore) saveNonMapFields() ([]datastore.Property, error) {
	// Create a temporary struct with only the non-map fields
	type nonMapFields struct {
		Key *datastore.Key `datastore:"-"`

		UpdatedAt time.Time `datastore:"updated_at"`

		GameId string `datastore:"-"`

		TurnCounter int32 `datastore:"turn_counter"`

		CurrentPlayer int32 `datastore:"current_player"`

		WorldData WorldDataDatastore `datastore:"world_data,noindex"`

		StateHash string `datastore:"state_hash"`

		Version int64 `datastore:"version"`

		Status models.GameStatus `datastore:"status"`

		Finished bool `datastore:"finished"`

		WinningPlayer int32 `datastore:"winning_player"`

		WinningTeam int32 `datastore:"winning_team"`

		CurrentGroupNumber int64 `datastore:"current_group_number"`
	}

	tmp := nonMapFields{

		Key: m.Key,

		UpdatedAt: m.UpdatedAt,

		GameId: m.GameId,

		TurnCounter: m.TurnCounter,

		CurrentPlayer: m.CurrentPlayer,

		WorldData: m.WorldData,

		StateHash: m.StateHash,

		Version: m.Version,

		Status: m.Status,

		Finished: m.Finished,

		WinningPlayer: m.WinningPlayer,

		WinningTeam: m.WinningTeam,

		CurrentGroupNumber: m.CurrentGroupNumber,
	}

	return datastore.SaveStruct(&tmp)
}

// Load implements the PropertyLoadSaver interface for GameStateDatastore.
// It deserializes JSON-encoded map fields back to Go maps.
func (m *GameStateDatastore) Load(props []datastore.Property) error {
	// Separate map properties from regular properties
	var regularProps []datastore.Property

	var PlayerStatesProp *datastore.Property

	for i := range props {
		switch props[i].Name {

		case "player_states":
			PlayerStatesProp = &props[i]

		default:
			regularProps = append(regularProps, props[i])
		}
	}

	// Load non-map fields using a temporary struct
	type nonMapFields struct {
		Key *datastore.Key `datastore:"-"`

		UpdatedAt time.Time `datastore:"updated_at"`

		GameId string `datastore:"-"`

		TurnCounter int32 `datastore:"turn_counter"`

		CurrentPlayer int32 `datastore:"current_player"`

		WorldData WorldDataDatastore `datastore:"world_data,noindex"`

		StateHash string `datastore:"state_hash"`

		Version int64 `datastore:"version"`

		Status models.GameStatus `datastore:"status"`

		Finished bool `datastore:"finished"`

		WinningPlayer int32 `datastore:"winning_player"`

		WinningTeam int32 `datastore:"winning_team"`

		CurrentGroupNumber int64 `datastore:"current_group_number"`
	}

	var tmp nonMapFields
	if err := datastore.LoadStruct(&tmp, regularProps); err != nil {
		return err
	}

	// Copy non-map fields back

	m.Key = tmp.Key

	m.UpdatedAt = tmp.UpdatedAt

	m.GameId = tmp.GameId

	m.TurnCounter = tmp.TurnCounter

	m.CurrentPlayer = tmp.CurrentPlayer

	m.WorldData = tmp.WorldData

	m.StateHash = tmp.StateHash

	m.Version = tmp.Version

	m.Status = tmp.Status

	m.Finished = tmp.Finished

	m.WinningPlayer = tmp.WinningPlayer

	m.WinningTeam = tmp.WinningTeam

	m.CurrentGroupNumber = tmp.CurrentGroupNumber

	// Deserialize PlayerStates from JSON
	if PlayerStatesProp != nil {
		var jsonBytes []byte
		switch v := PlayerStatesProp.Value.(type) {
		case []byte:
			jsonBytes = v
		case string:
			jsonBytes = []byte(v)
		default:
			return fmt.Errorf("unexpected type for player_states: %T", PlayerStatesProp.Value)
		}
		if len(jsonBytes) > 0 {
			m.PlayerStates = make(map[int32]PlayerStateDatastore)
			if err := json.Unmarshal(jsonBytes, &m.PlayerStates); err != nil {
				return fmt.Errorf("failed to unmarshal PlayerStates: %w", err)
			}
		}
	}

	return nil
}

// GameConfigurationDatastore is the Datastore entity for the source message.
type GameConfigurationDatastore struct {
	Key *datastore.Key `datastore:"-"`

	Players []GamePlayerDatastore `datastore:"players,noindex"`

	Teams []GameTeamDatastore `datastore:"teams,noindex"`

	IncomeConfigs IncomeConfigDatastore `datastore:"income_configs"`

	Settings GameSettingsDatastore `datastore:"settings"`
}

// IncomeConfigDatastore is the Datastore entity for the source message.
type IncomeConfigDatastore struct {
	Key *datastore.Key `datastore:"-"`

	StartingCoins int32 `datastore:"starting_coins"`

	GameIncome int32 `datastore:"game_income"`

	LandbaseIncome int32 `datastore:"landbase_income"`

	NavalbaseIncome int32 `datastore:"navalbase_income"`

	AirportbaseIncome int32 `datastore:"airportbase_income"`

	MissilesiloIncome int32 `datastore:"missilesilo_income"`

	MinesIncome int32 `datastore:"mines_income"`
}

// GamePlayerDatastore is the Datastore entity for the source message.
type GamePlayerDatastore struct {
	Key *datastore.Key `datastore:"-"`

	PlayerId int32 `datastore:"player_id"`

	UserId string `datastore:"user_id"`

	PlayerType string `datastore:"player_type"`

	Color string `datastore:"color"`

	TeamId int32 `datastore:"team_id"`

	Name string `datastore:"name"`

	IsActive bool `datastore:"is_active"`

	StartingCoins int32 `datastore:"starting_coins"`
}

// GameTeamDatastore is the Datastore entity for the source message.
type GameTeamDatastore struct {
	Key *datastore.Key `datastore:"-"`

	TeamId int32 `datastore:"team_id"`

	Name string `datastore:"name"`

	Color string `datastore:"color"`

	IsActive bool `datastore:"is_active"`
}

// GameSettingsDatastore is the Datastore entity for the source message.
type GameSettingsDatastore struct {
	Key *datastore.Key `datastore:"-"`

	AllowedUnits []int32 `datastore:"allowed_units,noindex"`

	TurnTimeLimit int32 `datastore:"turn_time_limit"`

	TeamMode string `datastore:"team_mode"`

	MaxTurns int32 `datastore:"max_turns"`
}

// PlayerStateDatastore is the Datastore entity for the source message.
type PlayerStateDatastore struct {
	Key *datastore.Key `datastore:"-"`

	Coins int32 `datastore:"coins"`

	IsActive bool `datastore:"is_active"`
}

// GameMoveDatastore is the Datastore entity for the source message.
type GameMoveDatastore struct {
	Key *datastore.Key `datastore:"-"`

	GameId string `datastore:"game_id"`

	Player int32 `datastore:"player"`

	GroupNumber int64 `datastore:"group_number"`

	MoveNumber int64 `datastore:"move_number"`

	MoveType []byte `datastore:"move_type,noindex"`

	Timestamp time.Time `datastore:"timestamp"`

	SequenceNum int64 `datastore:"sequence_num"`

	IsPermanent bool `datastore:"is_permanent"`

	Changes [][]byte `datastore:"changes,noindex"`

	Description string `datastore:"description"`
}

// Kind returns the Datastore kind name for GameMoveDatastore.
func (*GameMoveDatastore) Kind() string {
	return "GameMove"
}
